<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · CCBlade.jl</title><meta name="title" content="API Reference · CCBlade.jl"/><meta property="og:title" content="API Reference · CCBlade.jl"/><meta property="twitter:title" content="API Reference · CCBlade.jl"/><meta name="description" content="Documentation for CCBlade.jl."/><meta property="og:description" content="Documentation for CCBlade.jl."/><meta property="twitter:description" content="Documentation for CCBlade.jl."/><meta property="og:url" content="https://flow.byu.edu/CCBlade.jl/reference/"/><meta property="twitter:url" content="https://flow.byu.edu/CCBlade.jl/reference/"/><link rel="canonical" href="https://flow.byu.edu/CCBlade.jl/reference/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CCBlade.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Intro</a></li><li><a class="tocitem" href="../tutorial/">Quick Start</a></li><li><a class="tocitem" href="../howto/">Guided Examples</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Input-Structs"><span>Input Structs</span></a></li><li><a class="tocitem" href="#Output-Struct"><span>Output Struct</span></a></li><li><a class="tocitem" href="#Solve"><span>Solve</span></a></li><li><a class="tocitem" href="#Integrated-Loads"><span>Integrated Loads</span></a></li><li><a class="tocitem" href="#Airfoil-Evaluation"><span>Airfoil Evaluation</span></a></li><li><a class="tocitem" href="#Airfoil-Files"><span>Airfoil Files</span></a></li><li><a class="tocitem" href="#Airfoil-(and-Tip)-Corrections"><span>Airfoil (and Tip) Corrections</span></a></li><li><a class="tocitem" href="#Airfoil-Extrapolation"><span>Airfoil Extrapolation</span></a></li></ul></li><li><a class="tocitem" href="../theory/">Theory</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/byuflowlab/CCBlade.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/byuflowlab/CCBlade.jl/blob/master/docs/src/reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><p>This section describes the API in more detail.</p><h2 id="Input-Structs"><a class="docs-heading-anchor" href="#Input-Structs">Input Structs</a><a id="Input-Structs-1"></a><a class="docs-heading-anchor-permalink" href="#Input-Structs" title="Permalink"></a></h2><p>The rotor object is defined as follows.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CCBlade.Rotor" href="#CCBlade.Rotor"><code>CCBlade.Rotor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Rotor(Rhub, Rtip, B; precone=0.0, turbine=false,
    mach=nothing, re=nothing, rotation=nothing, tip=PrandtlTipHub())</code></pre><p>Parameters defining the rotor (apply to all sections).</p><p><strong>Arguments</strong></p><ul><li><code>Rhub::Float64</code>: hub radius (along blade length)</li><li><code>Rtip::Float64</code>: tip radius (along blade length)</li><li><code>B::Int64</code>: number of blades</li><li><code>precone::Float64</code>: precone angle</li><li><code>turbine::Bool</code>: true if using wind turbine conventions</li><li><code>mach::MachCorrection</code>: correction method for Mach number</li><li><code>re::ReCorrection</code>: correction method for Reynolds number</li><li><code>rotation::RotationCorrection</code>: correction method for blade rotation</li><li><code>tip::TipCorrection</code>: correction method for hub/tip loss</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/CCBlade.jl/blob/a7704cb3c6e71f21acf7ac6c1d3eb4a6f64c8692/src/CCBlade.jl#L29-L45">source</a></section></article><p>The precone angle is shown below (commonly used with wind turbines, less so with propellers).</p><p><img src="../precone.png" alt="precone"/></p><p>If there is precone then the Rhub and Rtip dimensions correspond to the length along the blade (instead of the radius from the center of rotation).  That way when precone is changed, the blade just rotates instead of shearing as is more common.  The <code>turbine</code> parameter is used for wind turbines, as discussed in <a href="../howto/#Wind-Turbine-Operation">Wind Turbine Operation</a>.  The remaining options are for airfoil (and tip loss) corrections and are discussed in <a href="#Airfoil-(and-Tip)-Corrections">Airfoil (and Tip) Corrections</a>. </p><p>The <code>Section</code> object is defined as follows:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CCBlade.Section" href="#CCBlade.Section"><code>CCBlade.Section</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Section(r, chord, theta, af)</code></pre><p>Define sectional properties for one station along rotor</p><p><strong>Arguments</strong></p><ul><li><code>r::Float64</code>: radial location along blade</li><li><code>chord::Float64</code>: corresponding local chord length</li><li><code>theta::Float64</code>: corresponding twist angle (radians)</li><li><code>af::Function or AFType</code>: if function form is: <code>cl, cd = af(alpha, Re, Mach)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/CCBlade.jl/blob/a7704cb3c6e71f21acf7ac6c1d3eb4a6f64c8692/src/CCBlade.jl#L65-L75">source</a></section></article><p>Radius, like the hub and tip radii, follows along the blade.  Note that we usually only specify interior <code>r</code> points (e.g., strict inequalities for <code>Rhub &lt; r &lt; Rtip</code>).  However, CCBlade will allow you to specify points all the way to r = Rtip and/or r = Rhub, but because the loads are always zero at the hub/tip, the computation is bypassed for efficiency.  The thrust/torque integration always extrapolates to zero loads at the tip so there is no benefit to including the ends, however there is no harm either. </p><p>Positive twist is shown below.  </p><p><img src="../inflow1.png" alt="inflow1"/></p><p>Airfoils are either a function as noted in the docstring, or a subtype of <code>AFType</code>, which in discussed in more detail in <a href="#Airfoil-Evaluation">Airfoil Evaluation</a>. </p><p>The remaining input is the operating point:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CCBlade.OperatingPoint" href="#CCBlade.OperatingPoint"><code>CCBlade.OperatingPoint</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OperatingPoint(Vx, Vy, rho; pitch=0.0, mu=1.0, asound=1.0)</code></pre><p>Operation point for a rotor. The x direction is the axial direction, and y direction is the tangential direction in the rotor plane. See Documentation for more detail on coordinate systems. <code>Vx</code> and <code>Vy</code> vary radially at same locations as <code>r</code> in the rotor definition.</p><p><strong>Arguments</strong></p><ul><li><code>Vx::Float64</code>: velocity in x-direction along blade</li><li><code>Vy::Float64</code>: velocity in y-direction along blade</li><li><code>pitch::Float64</code>: pitch angle (radians)</li><li><code>rho::Float64</code>: fluid density</li><li><code>mu::Float64</code>: fluid dynamic viscosity (unused if Re not included in airfoil data)</li><li><code>asound::Float64</code>: fluid speed of sound (unused if Mach not included in airfoil data)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/CCBlade.jl/blob/a7704cb3c6e71f21acf7ac6c1d3eb4a6f64c8692/src/CCBlade.jl#L93-L108">source</a></section></article><p>The inflow velocities <span>$V_x$</span> and <span>$V_y$</span> are seen in the figure above.  This allows to user to specify a completely general input, but usually these aren&#39;t specified directly.  Rather convenience functions are used to define these velocities across the blade (discussed below).  Dynamic viscosity is only need if the airfoil data contains multiple Reynolds number.  The speed of sound is only needed if the airfoil data contains multiple Mach numbers.  Pitch twists the entire blade in the same positive direction as twist.</p><p>A simple propeller would have <span>$V_x = V_\infty$</span> and <span>$V_y = \Omega r$</span>.  That&#39;s essentially what the <code>simple_op</code> convenence function provides (with the addition of accounting for precone).  </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CCBlade.simple_op" href="#CCBlade.simple_op"><code>CCBlade.simple_op</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">simple_op(Vinf, Omega, r, rho; pitch=0.0, mu=1.0, asound=1.0, precone=0.0)</code></pre><p>Uniform inflow through rotor.  Returns an OperatingPoint object.</p><p><strong>Arguments</strong></p><ul><li><code>Vinf::Float</code>: freestream speed (m/s)</li><li><code>Omega::Float</code>: rotation speed (rad/s)</li><li><code>r::Float</code>: radial location where inflow is computed (m)</li><li><code>rho::Float</code>: air density (kg/m^3)</li><li><code>pitch::Float</code>: pitch angle (rad)</li><li><code>mu::Float</code>: air viscosity (Pa * s)</li><li><code>asounnd::Float</code>: air speed of sound (m/s)</li><li><code>precone::Float</code>: precone angle (rad)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/CCBlade.jl/blob/a7704cb3c6e71f21acf7ac6c1d3eb4a6f64c8692/src/CCBlade.jl#L527-L541">source</a></section></article><p>For wind turbines, a convenience function is provided <code>windturbine_op</code> that also includes yaw, tilt, azimuth, hub height, and a shear exponent.  </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CCBlade.windturbine_op" href="#CCBlade.windturbine_op"><code>CCBlade.windturbine_op</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">windturbine_op(Vhub, Omega, pitch, r, precone, yaw, tilt, azimuth, hubHt, shearExp, rho, mu=1.0, asound=1.0)</code></pre><p>Compute relative wind velocity components along blade accounting for inflow conditions and orientation of turbine.  See Documentation for angle definitions.</p><p><strong>Arguments</strong></p><ul><li><code>Vhub::Float64</code>: freestream speed at hub (m/s)</li><li><code>Omega::Float64</code>: rotation speed (rad/s)</li><li><code>pitch::Float64</code>: pitch angle (rad)</li><li><code>r::Float64</code>: radial location where inflow is computed (m)</li><li><code>precone::Float64</code>: precone angle (rad)</li><li><code>yaw::Float64</code>: yaw angle (rad)</li><li><code>tilt::Float64</code>: tilt angle (rad)</li><li><code>azimuth::Float64</code>: azimuth angle to evaluate at (rad)</li><li><code>hubHt::Float64</code>: hub height (m) - used for shear</li><li><code>shearExp::Float64</code>: power law shear exponent</li><li><code>rho::Float64</code>: air density (kg/m^3)</li><li><code>mu::Float64</code>: air viscosity (Pa * s)</li><li><code>asound::Float64</code>: air speed of sound (m/s)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/CCBlade.jl/blob/a7704cb3c6e71f21acf7ac6c1d3eb4a6f64c8692/src/CCBlade.jl#L557-L577">source</a></section></article><p><img src="../angles.png" alt/></p><p>To account for the velocity change across the hub face we compute the height of each blade location relative to the hub using coordinate transformations (where <span>$\Phi$</span> is the precone angle):</p><p class="math-container">\[  z_h = r \cos\Phi \cos\psi \cos\Theta + r \sin\Phi\sin\Theta\]</p><p>then apply the shear exponent (<span>$\alpha$</span>):</p><p class="math-container">\[  V_{shear} = V_{hub} \left(1 + \frac{z_h}{H_{hub}} \right)^\alpha\]</p><p>where <span>$H_{hub}$</span> is the hub height.  Finally, we can compute the x- and y-components of velocity with additional coordinate transformations:</p><p class="math-container">\[\begin{aligned}
V_x &amp;= V_{shear} ((\cos \gamma \sin \Theta \cos \psi + \sin \gamma \sin \psi)\sin \Phi + \cos \gamma \cos \Theta \cos \Phi)\\
V_y &amp;= V_{shear} (\cos \gamma \sin \Theta\sin \psi - \sin \gamma \cos \psi) + \Omega r \cos\Phi
\end{aligned}\]</p><h2 id="Output-Struct"><a class="docs-heading-anchor" href="#Output-Struct">Output Struct</a><a id="Output-Struct-1"></a><a class="docs-heading-anchor-permalink" href="#Output-Struct" title="Permalink"></a></h2><p>The full list of <code>Outputs</code> is as follows:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CCBlade.Outputs" href="#CCBlade.Outputs"><code>CCBlade.Outputs</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Outputs(Np, Tp, a, ap, u, v, phi, alpha, W, cl, cd, cn, ct, F, G)</code></pre><p>Outputs from the BEM solver along the radius.</p><p><strong>Arguments</strong></p><ul><li><code>Np::Float64</code>: normal force per unit length</li><li><code>Tp::Float64</code>: tangential force per unit length</li><li><code>a::Float64</code>: axial induction factor</li><li><code>ap::Float64</code>: tangential induction factor</li><li><code>u::Float64</code>: axial induced velocity</li><li><code>v::Float64</code>: tangential induced velocity</li><li><code>phi::Float64</code>: inflow angle</li><li><code>alpha::Float64</code>: angle of attack</li><li><code>W::Float64</code>: inflow velocity</li><li><code>cl::Float64</code>: lift coefficient</li><li><code>cd::Float64</code>: drag coefficient</li><li><code>cn::Float64</code>: normal force coefficient</li><li><code>ct::Float64</code>: tangential force coefficient</li><li><code>F::Float64</code>: hub/tip loss correction</li><li><code>G::Float64</code>: effective hub/tip loss correction for induced velocities: <code>u = Vx * a * G, v = Vy * ap * G</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/CCBlade.jl/blob/a7704cb3c6e71f21acf7ac6c1d3eb4a6f64c8692/src/CCBlade.jl#L129-L150">source</a></section></article><p>Most of these parameters are defined in the figure below.  The variables Np and Tp (where p is short for prime, as in a force per unit length) are in the cn and ct directions respectively.</p><p><img src="../inflow2.png" alt="inflow2"/></p><p>When using broadcasting to retrieve multiple outputs at once (as would be commonly done for multiple sections along a blade) the return type is a <code>StructArray</code> from <a href="https://github.com/JuliaArrays/StructArrays.jl">the StructArrays.jl package</a>. A <code>StructArray</code> acts like a normal <code>Array</code> when indexed with integers, but can also be indexed with the output names like <code>Np</code> and <code>Tp</code>. To show this, we&#39;ll create an example <code>Output</code> array of length 4 with random data:</p><pre><code class="language-julia hljs">using CCBlade

# Create an array of `N` Outputs
N = 4
outs = Outputs.(rand(N), rand(N), rand(N), rand(N), rand(N), rand(N), rand(N), rand(N), rand(N), rand(N), rand(N), rand(N), rand(N), rand(N), rand(N))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element StructArray(::Vector{Float64}, ::Vector{Float64}, ::Vector{Float64}, ::Vector{Float64}, ::Vector{Float64}, ::Vector{Float64}, ::Vector{Float64}, ::Vector{Float64}, ::Vector{Float64}, ::Vector{Float64}, ::Vector{Float64}, ::Vector{Float64}, ::Vector{Float64}, ::Vector{Float64}, ::Vector{Float64}) with eltype Outputs{Float64}:
 Outputs{Float64}(0.14237187097570536, 0.8954961105165499, 0.025407198688379817, 0.33429943296928755, 0.5401085023326448, 0.37638549855150283, 0.6060592522017582, 0.5508962578608726, 0.6101667435202718, 0.5971913441651859, 0.2279700419079982, 0.507593237933119, 0.7431458284434066, 0.10281649967394235, 0.6768959050510027)
 Outputs{Float64}(0.24882656154825056, 0.9491213792879856, 0.4908635781645714, 0.05688259923698524, 0.5617732674252501, 0.6415031675393346, 0.26618471311053515, 0.6272643125041704, 0.24082080998683608, 0.5637550953204296, 0.10289493189564436, 0.7262886379195013, 0.03278033903582689, 0.8198850498820197, 0.4159269752106487)
 Outputs{Float64}(0.7844482170645465, 0.7391651030342128, 0.27801081406632167, 0.556875360589769, 0.8100096505730865, 0.6351831724474021, 0.38334073148674197, 0.9306245800727769, 0.762036214766927, 0.058046345645709985, 0.8665565262229854, 0.3439569261894153, 0.56667724492236, 0.7068423610699092, 0.87515454969027)
 Outputs{Float64}(0.6859457866840619, 0.914025971168414, 0.27080798635257086, 0.4546034015040965, 0.03259413404639233, 0.4169827971933816, 0.2329785287426539, 0.8828497261799467, 0.7510955988548512, 0.903843754573936, 0.8446923367947977, 0.9304040468988439, 0.9970252365552867, 0.7429251305584632, 0.7736828449420803)</code></pre><p>Now we can retrieve all of the inputs for e.g. the third entry by indexing with an integer:</p><pre><code class="language-julia hljs">outs[3]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Outputs{Float64}(0.7844482170645465, 0.7391651030342128, 0.27801081406632167, 0.556875360589769, 0.8100096505730865, 0.6351831724474021, 0.38334073148674197, 0.9306245800727769, 0.762036214766927, 0.058046345645709985, 0.8665565262229854, 0.3439569261894153, 0.56667724492236, 0.7068423610699092, 0.87515454969027)</code></pre><p>But we can also get all of the e.g. <code>Np</code> outputs using <code>outs.Np</code>:</p><pre><code class="language-julia hljs">outs.Np</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Float64}:
 0.14237187097570536
 0.24882656154825056
 0.7844482170645465
 0.6859457866840619</code></pre><p>This was shown in the introductory <a href="../tutorial/">tutorial</a>. The same is true for the <a href="#CCBlade.Section"><code>Section</code></a> and <a href="#CCBlade.OperatingPoint"><code>OperatingPoint</code></a> structs.</p><p>One subtle notes regarding the way the tip-loss factor works.  The BEM methodology applies hub/tip losses to the loads rather than to the velocities.  This is the most common way to implement a BEM, but it means that the raw velocities may be misleading as they do not contain any hub/tip loss corrections.  To fix this we compute the effective hub/tip losses that would produce the same thrust/torque.  In other words: <span>$C_T = 4 a (1 + a) F = 4 a G (1 + a G)$</span> We solve this for G, and multiply it against the returned wake velocities <span>$u$</span> and <span>$v$</span> (but not the induction factors).  Doing so allows us to return consistent values for the wake velocities, which may be of interest when computing interactions between rotor wakes and other objects.</p><h2 id="Solve"><a class="docs-heading-anchor" href="#Solve">Solve</a><a id="Solve-1"></a><a class="docs-heading-anchor-permalink" href="#Solve" title="Permalink"></a></h2><p>Solve is the main function that takes in the three input structs (<code>Rotor</code>, <code>Section</code>, <code>OperatingPoint</code>) and returns the output struct (<code>Outputs</code>).  Often broadcasting is used to call this function at multiple sections, or multiple sections and multiple operating points.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CCBlade.solve" href="#CCBlade.solve"><code>CCBlade.solve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve(rotor, section, op; npts=10, forcebackwardsearch=false, epsilon_everywhere=false)</code></pre><p>Solve the BEM equations for given rotor geometry and operating point.</p><p><strong>Arguments</strong></p><ul><li><code>rotor::Rotor</code>: rotor properties</li><li><code>section::Section</code>: section properties</li><li><code>op::OperatingPoint</code>: operating point</li><li><code>npts::Int = 10</code>: number of discretization points for <code>phi</code> state variable, used to find bracket for residual solve</li><li><code>forcebackwardsearch::Bool = false</code>: if true, force bracket search from high <code>phi</code> values to low, otherwise let <code>solve</code> decide</li><li><code>epsilon_everywhere::Bool = false</code>: if true, don&#39;t evaluate at intersections of <code>phi</code> quadrants (<code>pi/2</code>, <code>-pi/2</code>, etc.)</li><li><code>implicitad_option=true</code>: if true, uses ImplicitAD to compute derivatives around solver when using AD; if false, bypasses ImplicitAD</li></ul><p><strong>Returns</strong></p><ul><li><code>outputs::Outputs</code>: BEM output data including loads, induction factors, etc.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/CCBlade.jl/blob/a7704cb3c6e71f21acf7ac6c1d3eb4a6f64c8692/src/CCBlade.jl#L364-L380">source</a></section></article><h2 id="Integrated-Loads"><a class="docs-heading-anchor" href="#Integrated-Loads">Integrated Loads</a><a id="Integrated-Loads-1"></a><a class="docs-heading-anchor-permalink" href="#Integrated-Loads" title="Permalink"></a></h2><p>After solving, the distributed loads can be integrated to provide thrust and torque using the function <code>thrusttorque</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CCBlade.thrusttorque-Union{Tuple{TO}, Tuple{Any, Any, Vector{TO}}} where TO" href="#CCBlade.thrusttorque-Union{Tuple{TO}, Tuple{Any, Any, Vector{TO}}} where TO"><code>CCBlade.thrusttorque</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">thrusttorque(rotor, sections, outputs::AbstractVector{TO}) where TO</code></pre><p>integrate the thrust/torque across the blade, including 0 loads at hub/tip, using a trapezoidal rule.</p><p><strong>Arguments</strong></p><ul><li><code>rotor::Rotor</code>: rotor object</li><li><code>sections::Vector{Section}</code>: rotor object</li><li><code>outputs::Vector{Outputs}</code>: output data along blade</li></ul><p><strong>Returns</strong></p><ul><li><code>T::Float64</code>: thrust (along x-dir see Documentation).</li><li><code>Q::Float64</code>: torque (along x-dir see Documentation).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/CCBlade.jl/blob/a7704cb3c6e71f21acf7ac6c1d3eb4a6f64c8692/src/CCBlade.jl#L621-L635">source</a></section></article><p>The method extends to loads to the hub/tip (where the loads go to zero) to capture the small contribution to thrust and torque from the ends of the <code>r</code> vector to <code>Rhub</code> and <code>Rtip</code>.</p><p>There is also an overloaded version where a matrix of outputs is input for azimuthal averaging (mainly used for wind turbines).</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CCBlade.thrusttorque-Union{Tuple{TO}, Tuple{Any, Any, Matrix{TO}}} where TO" href="#CCBlade.thrusttorque-Union{Tuple{TO}, Tuple{Any, Any, Matrix{TO}}} where TO"><code>CCBlade.thrusttorque</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">thrusttorque(rotor, sections, outputs::AbstractMatrix{TO}) where TO</code></pre><p>Integrate the thrust/torque across the blade given an array of output data. Generally used for azimuthal averaging of thrust/torque. <code>outputs[i, j]</code> corresponds to <code>sections[i], azimuth[j]</code>.  Integrates across azimuth</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/CCBlade.jl/blob/a7704cb3c6e71f21acf7ac6c1d3eb4a6f64c8692/src/CCBlade.jl#L655-L661">source</a></section></article><p>Often we want to nondimensionalize the outputs.  The nondimensionalization uses different conventions depending on the name assigned in <code>rotortype</code>.  </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CCBlade.nondim" href="#CCBlade.nondim"><code>CCBlade.nondim</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nondim(T, Q, Vhub, Omega, rho, rotor, rotortype)</code></pre><p>Nondimensionalize the outputs.</p><p><strong>Arguments</strong></p><ul><li><code>T::Float64</code>: thrust (N)</li><li><code>Q::Float64</code>: torque (N-m)</li><li><code>Vhub::Float64</code>: hub speed used in turbine normalization (m/s)</li><li><code>Omega::Float64</code>: rotation speed used in propeller normalization (rad/s)</li><li><code>rho::Float64</code>: air density (kg/m^3)</li><li><code>rotor::Rotor</code>: rotor object</li><li><code>rotortype::String</code>: normalization type</li></ul><p><strong>Returns</strong></p><p><code>if rotortype == &quot;windturbine&quot;</code></p><ul><li><code>CP::Float64</code>: power coefficient</li><li><code>CT::Float64</code>: thrust coefficient</li><li><code>CQ::Float64</code>: torque coefficient</li></ul><p><code>if rotortype == &quot;propeller&quot;</code></p><ul><li><code>eff::Float64</code>: efficiency</li><li><code>CT::Float64</code>: thrust coefficient</li><li><code>CQ::Float64</code>: torque coefficient</li></ul><p><code>if rotortype == &quot;helicopter&quot;</code></p><ul><li><code>FM::Float64</code>: figure of merit</li><li><code>CT::Float64</code>: thrust coefficient</li><li><code>CQ or CP::Float64</code>: torque/power coefficient (they are identical)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/CCBlade.jl/blob/a7704cb3c6e71f21acf7ac6c1d3eb4a6f64c8692/src/CCBlade.jl#L679-L709">source</a></section></article><p>For <code>rotortype = &quot;windturbine&quot;</code> the following outputs are returned:</p><p class="math-container">\[\begin{aligned}
C_P &amp;= \frac{P}{q A V_{hub}}\\
C_T &amp;= \frac{T}{q A}\\
C_Q &amp;= \frac{Q}{q R_{disk} A}\\
\end{aligned}\]</p><p>where</p><p class="math-container">\[\begin{aligned}
R_{disk} &amp;= R_{tip} \cos(\text{precone})\\
A &amp;= \pi R_{disk}^2\\
q &amp;= \frac{1}{2}\rho V_{hub}^2\\
\end{aligned}\]</p><p>For <code>type = &quot;propeller&quot;</code> the return outputs are:</p><p class="math-container">\[\begin{aligned}
\eta &amp;= \frac{T V_{hub}}{P}\\
C_T &amp;= \frac{T}{\rho n^2 D^4}\\
C_Q &amp;= \frac{Q}{\rho n^2 D^5}\\
\end{aligned}\]</p><p>where</p><p class="math-container">\[\begin{aligned}
D &amp;= 2 R_{disk}\\
n &amp;= \frac{\Omega}{2\pi}
\end{aligned}\]</p><p>For <code>type = &quot;helicopter&quot;</code> the return outputs are:</p><p class="math-container">\[\begin{aligned}
FM &amp;= \frac{C_T^{3/2}}{\sqrt{2} C_P}\\
C_T &amp;= \frac{T}{\rho A (\Omega R_{disk})^2}\\
C_P &amp;= \frac{P}{\rho A (\Omega R_{disk})^3}\\
\end{aligned}\]</p><p>note that with this definition <code>C_Q = C_P</code>.</p><h2 id="Airfoil-Evaluation"><a class="docs-heading-anchor" href="#Airfoil-Evaluation">Airfoil Evaluation</a><a id="Airfoil-Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Airfoil-Evaluation" title="Permalink"></a></h2><p>The main airfoil evaluation function is <code>afeval</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CCBlade.afeval-Tuple{AFType, Any, Any, Any}" href="#CCBlade.afeval-Tuple{AFType, Any, Any, Any}"><code>CCBlade.afeval</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">afeval(af::AFType, alpha, Re, Mach)</code></pre><p>Evaluate airfoil aerodynamic performance</p><p><strong>Arguments</strong></p><ul><li><code>af::AFType or Function</code>: dispatch on AFType or if function call: <code>cl, cd = af(alpha, Re, Mach)</code></li><li><code>alpha::Float64</code>: angle of attack in radians</li><li><code>Re::Float64</code>: Reynolds number</li><li><code>Mach::Float64</code>: Mach number</li></ul><p><strong>Returns</strong></p><ul><li><code>cl::Float64</code>: lift coefficient</li><li><code>cd::Float64</code>: drag coefficient</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/CCBlade.jl/blob/a7704cb3c6e71f21acf7ac6c1d3eb4a6f64c8692/src/airfoils.jl#L88-L102">source</a></section></article><p>It dispatches based on subtypes of <code>AFType</code> or any <code>Function</code> of the form noted in the docstring.  Several subtypes of <code>AFType</code> are implemented.  The first is <code>SimpleAF</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CCBlade.SimpleAF" href="#CCBlade.SimpleAF"><code>CCBlade.SimpleAF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SimpleAF(m, alpha0, clmax, clmin, cd0, cd2)</code></pre><p>A simple parameterized lift and drag curve.  </p><ul><li><code>cl = m (alpha - alpha0)</code> (capped by clmax/clmin)</li><li><code>cd = cd0 + cd2 * cl^2</code></li></ul><p><strong>Arguments</strong></p><ul><li><code>m::Float64</code>: lift curve slope</li><li><code>alpha0::Float64</code>: zero-lift angle of attack</li><li><code>clmax::Float64</code>: maximum lift coefficient</li><li><code>clmin::Float64</code>: minimum lift coefficient</li><li><code>cd0::Float64</code>: zero lift drag</li><li><code>cd2::Float64</code>: quadratic drag term</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/CCBlade.jl/blob/a7704cb3c6e71f21acf7ac6c1d3eb4a6f64c8692/src/airfoils.jl#L116-L130">source</a></section></article><p>This form is mostly useful for testing, or really simple analyse.  Next, and perhaps the most common type is <code>AlphaAF</code>. This type takes in arrays of data and creates an Akima spline with variation just in angle of attack.  It can also be initialized from a file (format discussed below).  </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CCBlade.AlphaAF" href="#CCBlade.AlphaAF"><code>CCBlade.AlphaAF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AlphaAF(alpha, cl, cd, info, Re, Mach)
AlphaAF(alpha, cl, cd, info, Re=0.0, Mach=0.0)
AlphaAF(alpha, cl, cd, info=&quot;CCBlade generated airfoil&quot;, Re=0.0, Mach=0.0)
AlphaAF(filename::String; radians=true)</code></pre><p>Airfoil data that varies with angle of attack.  Data is fit with an Akima spline.</p><p><strong>Arguments</strong></p><ul><li><code>alpha::Vector{Float64}</code>: angles of attack</li><li><code>cl::Vector{Float64}</code>: corresponding lift coefficients</li><li><code>cd::Vector{Float64}</code>: corresponding drag coefficients</li><li><code>info::String</code>: a description of this airfoil data (just informational)</li><li><code>Re::Float64</code>: Reynolds number data was taken at (just informational)</li><li><code>Mach::Float64</code>: Mach number data was taken at (just informational)</li></ul><p>or</p><p>a file</p><p><strong>Arguments</strong></p><ul><li><code>filename::String</code>: name/path of file to read in</li><li><code>radians::Bool</code>: true if angle of attack in file is given in radians</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/CCBlade.jl/blob/a7704cb3c6e71f21acf7ac6c1d3eb4a6f64c8692/src/airfoils.jl#L154-L177">source</a></section></article><p>Similar forms exist for variation with angle of attack and Reynolds number:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CCBlade.AlphaReAF" href="#CCBlade.AlphaReAF"><code>CCBlade.AlphaReAF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AlphaReAF(alpha, Re, cl, cd, info, Mach)
AlphaReAF(alpha, Re, cl, cd, info)
AlphaReAF(alpha, Re, cl, cd)
read_AlphaReAF(filenames::Vector{String}; radians=true)</code></pre><p>Airfoil data that varies with angle of attack and Reynolds number.   Data is fit with a recursive Akima spline.</p><p><strong>Arguments</strong></p><ul><li><code>alpha::Vector{Float64}</code>: angles of attack</li><li><code>Re::Vector{Float64}</code>: Reynolds numbers</li><li><code>cl::Matrix{Float64}</code>: lift coefficients where cl[i, j] corresponds to alpha[i], Re[j]</li><li><code>cd::Matrix{Float64}</code>: drag coefficients where cd[i, j] corresponds to alpha[i], Re[j]</li><li><code>info::String</code>: a description of this airfoil data (just informational)</li><li><code>Mach::Float64</code>: Mach number data was taken at (just informational)</li></ul><p>or</p><p>filenames with one file per Reynolds number.</p><p><strong>Arguments</strong></p><ul><li><code>filenames::Vector{String}</code>: name/path of files to read in, each at a different Reynolds number in ascending order</li><li><code>radians::Bool</code>: true if angle of attack in file is given in radians</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/CCBlade.jl/blob/a7704cb3c6e71f21acf7ac6c1d3eb4a6f64c8692/src/airfoils.jl#L230-L254">source</a></section></article><p>angle of attack and Mach number:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CCBlade.AlphaMachAF" href="#CCBlade.AlphaMachAF"><code>CCBlade.AlphaMachAF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AlphaMachAF(alpha, Mach, cl, cd, info, Re)
AlphaMachAF(alpha, Mach, cl, cd, info)
AlphaMachAF(alpha, Mach, cl, cd)
AlphaMachAF(filenames::Vector{String}; radians=true)</code></pre><p>Airfoil data that varies with angle of attack and Mach number.   Data is fit with a recursive Akima spline.</p><p><strong>Arguments</strong></p><ul><li><code>alpha::Vector{Float64}</code>: angles of attack</li><li><code>Mach::Vector{Float64}</code>: Mach numbers</li><li><code>cl::Matrix{Float64}</code>: lift coefficients where cl[i, j] corresponds to alpha[i], Mach[j]</li><li><code>cd::Matrix{Float64}</code>: drag coefficients where cd[i, j] corresponds to alpha[i], Mach[j]</li><li><code>info::String</code>: a description of this airfoil data (just informational)</li><li><code>Re::Float64</code>: Reynolds number data was taken at (just informational)</li></ul><p>or</p><p>filenames with one file per Mach number.</p><p><strong>Arguments</strong></p><ul><li><code>filenames::Vector{String}</code>: name/path of files to read in, each at a different Mach number in ascending order</li><li><code>radians::Bool</code>: true if angle of attack in file is given in radians</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/CCBlade.jl/blob/a7704cb3c6e71f21acf7ac6c1d3eb4a6f64c8692/src/airfoils.jl#L308-L332">source</a></section></article><p>and all three (angle of attack, Reynolds number, Mach number):</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CCBlade.AlphaReMachAF" href="#CCBlade.AlphaReMachAF"><code>CCBlade.AlphaReMachAF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AlphaReMachAF(alpha, Re, Mach, cl, cd, info)
AlphaReMachAF(alpha, Re, Mach, cl, cd)
AlphaReMachAF(filenames::Matrix{String}; radians=true)</code></pre><p>Airfoil data that varies with angle of attack, Reynolds number, and Mach number.   Data is fit with a recursive Akima spline.</p><p><strong>Arguments</strong></p><ul><li><code>alpha::Vector{Float64}</code>: angles of attack</li><li><code>Re::Vector{Float64}</code>: Reynolds numbers</li><li><code>Mach::Vector{Float64}</code>: Mach numbers</li><li><code>cl::Array{Float64}</code>: lift coefficients where cl[i, j, k] corresponds to alpha[i], Re[j], Mach[k]</li><li><code>cd::Array{Float64}</code>: drag coefficients where cd[i, j, k] corresponds to alpha[i], Re[j], Mach[k]</li><li><code>info::String</code>: a description of this airfoil data (just informational)</li></ul><p>or files with one per Re/Mach combination</p><p><strong>Arguments</strong></p><ul><li><code>filenames::Matrix{String}</code>: name/path of files to read in.  filenames[i, j] corresponds to Re[i] Mach[j] with Reynolds number and Mach number in ascending order.</li><li><code>radians::Bool</code>: true if angle of attack in file is given in radians</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/CCBlade.jl/blob/a7704cb3c6e71f21acf7ac6c1d3eb4a6f64c8692/src/airfoils.jl#L388-L409">source</a></section></article><p>More generally the user can provide any function of the form <code>cl, cd = af(alpha, Re Mach)</code> or can create their own subtypes of <code>AFType</code> to be used by CCBlade.</p><h2 id="Airfoil-Files"><a class="docs-heading-anchor" href="#Airfoil-Files">Airfoil Files</a><a id="Airfoil-Files-1"></a><a class="docs-heading-anchor-permalink" href="#Airfoil-Files" title="Permalink"></a></h2><p>Because many of these formats require storing long vectors/matrices of data, it is convenient to store them in files.  There are multiple convenience methods for reading and writing files based on the implemented <code>AFType</code> subtypes.  The file format for all airfoil files is as follows:</p><p>______<br/>informational line (arbitrary string just for information)<br/>Re (float, Reynolds number data was taken at)<br/>Mach (float, Mach number data was taken at)<br/>alpha1  cl1  cd1  (columns of data separated by space for angle of attack, lift coefficient, and drag coefficient)<br/>alpha2  cl2  cd2<br/>alpha3  cl3  cd3<br/>...<br/>–––</p><p>In addition to reading these in directly, you can write data to a file, which is dispatched based on the <code>AFType</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CCBlade.write_af" href="#CCBlade.write_af"><code>CCBlade.write_af</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">write_af(filename(s), af::AFType; radians=true)</code></pre><p>Write airfoil data to file</p><p><strong>Arguments</strong></p><ul><li><code>filename(s)::String or Vector{String} or Matrix{String}</code>: name/path of file to write to</li><li><code>af::AFType</code>: writing is dispatched based on type (AlphaAF, AlphaReAF, etc.)</li><li><code>radians::Bool</code>: true if you want angle of attack to be written in radians</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/CCBlade.jl/blob/a7704cb3c6e71f21acf7ac6c1d3eb4a6f64c8692/src/airfoils.jl#L211-L220">source</a></section></article><h2 id="Airfoil-(and-Tip)-Corrections"><a class="docs-heading-anchor" href="#Airfoil-(and-Tip)-Corrections">Airfoil (and Tip) Corrections</a><a id="Airfoil-(and-Tip)-Corrections-1"></a><a class="docs-heading-anchor-permalink" href="#Airfoil-(and-Tip)-Corrections" title="Permalink"></a></h2><p>Various airfoil correction methods exist for Mach number, Reynolds number, and rotation effects.  Additionally, custom tip loss corrections can be specified.  For Mach number and Reynolds number the form is similar.  For Mach number, there is the <code>mach_correction</code> function that dispatches based on subtypes of <code>MachCorrection</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CCBlade.mach_correction-Tuple{MachCorrection, Any, Any, Any}" href="#CCBlade.mach_correction-Tuple{MachCorrection, Any, Any, Any}"><code>CCBlade.mach_correction</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mach_correction(::MachCorrection, cl, cd, Mach)</code></pre><p>Mach number correction for lift/drag coefficient</p><p><strong>Arguments</strong></p><ul><li><code>mc::MachCorrection</code>: used for dispatch</li><li><code>cl::Float64</code>: lift coefficient before correction</li><li><code>cd::Float64</code>: drag coefficient before correction</li><li><code>Mach::Float64</code>: Mach number</li></ul><p><strong>Returns</strong></p><ul><li><code>cl::Float64</code>: lift coefficient after correction</li><li><code>cd::Float64</code>: drag coefficient after correction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/CCBlade.jl/blob/a7704cb3c6e71f21acf7ac6c1d3eb4a6f64c8692/src/airfoils.jl#L477-L491">source</a></section></article><p>For example, a Prandtl-Glauert correction is available:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CCBlade.mach_correction-Tuple{PrandtlGlauert, Any, Any, Any}" href="#CCBlade.mach_correction-Tuple{PrandtlGlauert, Any, Any, Any}"><code>CCBlade.mach_correction</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mach_correction(::PrandtlGlauert, cl, cd, Mach)</code></pre><p>Prandtl/Glauert Mach number correction for lift coefficient</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/CCBlade.jl/blob/a7704cb3c6e71f21acf7ac6c1d3eb4a6f64c8692/src/airfoils.jl#L496-L500">source</a></section></article><p>Similarly, Reynolds number corrections use the <code>re_correction</code> function with dispatching based on subtypes of <code>ReCorrection</code></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CCBlade.re_correction-Tuple{ReCorrection, Any, Any, Any}" href="#CCBlade.re_correction-Tuple{ReCorrection, Any, Any, Any}"><code>CCBlade.re_correction</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">re_correction(re::ReCorrection, cl, cd, Re)</code></pre><p>Reynolds number correction for lift/drag coefficient</p><p><strong>Arguments</strong></p><ul><li><code>re::ReCorrection</code>: used for dispatch</li><li><code>cl::Float64</code>: lift coefficient before correction</li><li><code>cd::Float64</code>: drag coefficient before correction</li><li><code>Re::Float64</code>: Reynolds number</li></ul><p><strong>Returns</strong></p><ul><li><code>cl::Float64</code>: lift coefficient after correction</li><li><code>cd::Float64</code>: drag coefficient after correction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/CCBlade.jl/blob/a7704cb3c6e71f21acf7ac6c1d3eb4a6f64c8692/src/airfoils.jl#L511-L525">source</a></section></article><p>A skin friction model based on flat plate increases in drag coefficient with Reynolds number is implemented:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CCBlade.SkinFriction" href="#CCBlade.SkinFriction"><code>CCBlade.SkinFriction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SkinFriction(Re0, p)</code></pre><p>Skin friction model for a flat plate. <code>cd *= (Re0 / Re)^p</code></p><p><strong>Arguments</strong></p><ul><li><code>Re0::Float64</code>: reference Reynolds number (i.e., no corrections at this number)</li><li><code>p::Float64</code>: exponent in flat plate model.  0.5 for laminar (Blasius solution), ~0.2 for fully turbulent (Schlichting empirical fit)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/CCBlade.jl/blob/a7704cb3c6e71f21acf7ac6c1d3eb4a6f64c8692/src/airfoils.jl#L531-L540">source</a></section></article><p>For convenience, there is also <code>LaminarSkinFriction(Re0)</code> and <code>TurbulentSkinFriction(Re0)</code> to set the exponent <code>p</code> for typical values for fully laminar and fully turbulent flow respectively.</p><p>Rotational corrections for 3D stall delay use the <code>rotation_correction</code> function that dispatches on subtypes of <code>RotationCorrection</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CCBlade.rotation_correction" href="#CCBlade.rotation_correction"><code>CCBlade.rotation_correction</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rotation_correction(rc::RotationCorrection, cl, cd, cr, rR, tsr, alpha, phi=alpha, alpha_max_corr=30*pi/180)</code></pre><p>Rotation correction (3D stall delay).</p><p><strong>Arguments</strong></p><ul><li><code>rc::RotationCorrection</code>: used for dispatch</li><li><code>cl::Float64</code>: lift coefficient before correction</li><li><code>cd::Float64</code>: drag coefficient before correction</li><li><code>cr::Float64</code>: local chord / local radius</li><li><code>rR::Float64</code>: local radius / tip radius</li><li><code>tsr::Float64</code>: local tip speed ratio (Omega r / Vinf)</li><li><code>alpha::Float64</code>: local angle of attack</li><li><code>phi::Float64</code>: local inflow angles (defaults to angle of attack is precomputing since it is only known for on-the-fly computations)</li><li><code>alpha_max_corr::Float64</code>: angle of attack for maximum correction (tapers off to zero by 90 degrees)</li></ul><p><strong>Returns</strong></p><ul><li><code>cl::Float64</code>: lift coefficient after correction</li><li><code>cd::Float64</code>: drag coefficient after correction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/CCBlade.jl/blob/a7704cb3c6e71f21acf7ac6c1d3eb4a6f64c8692/src/airfoils.jl#L562-L581">source</a></section></article><p>A supplied correction method uses the Du-Selig method for lift and the Eggers method for drag.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CCBlade.DuSeligEggers" href="#CCBlade.DuSeligEggers"><code>CCBlade.DuSeligEggers</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DuSeligEggers(a, b, d, m, alpha0)
DuSeligEggers(a=1.0, b=1.0, d=1.0, m=2*pi, alpha0=0.0)  # uses defaults</code></pre><p>DuSelig correction for lift an Eggers correction for drag.</p><p><strong>Arguments</strong></p><ul><li><code>a, b, d::Float64</code>: parameters in Du-Selig paper.  Normally just 1.0 for each.</li><li><code>m::Float64</code>: lift curve slope.  Defaults to 2 pi for zero argument version.</li><li><code>alpha0::Float64</code>: zero-lift angle of attack.  Defaults to 0 for zero argument version.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/CCBlade.jl/blob/a7704cb3c6e71f21acf7ac6c1d3eb4a6f64c8692/src/airfoils.jl#L586-L596">source</a></section></article><p>Finally, tip loss corrections are provided by the <code>tip_correction</code> function dispatching based on <code>TipCorrection</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CCBlade.tip_correction" href="#CCBlade.tip_correction"><code>CCBlade.tip_correction</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tip_correction(::TipCorrection, r, Rhub, Rtip, phi, B)</code></pre><p>Tip corrections for 3D flow.</p><p><strong>Arguments</strong></p><ul><li><code>tc::TipCorrection</code>: used for dispatch</li><li><code>r::Float64</code>: local radius</li><li><code>Rhub::Float64</code>: hub radius</li><li><code>Rtip::Float64</code>: tip radius</li><li><code>phi::Float64</code>: inflow angle</li><li><code>B::Integer</code>: number of blades</li></ul><p><strong>Returns</strong></p><ul><li><code>F::Float64</code>: tip loss factor to multiple against loads.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/CCBlade.jl/blob/a7704cb3c6e71f21acf7ac6c1d3eb4a6f64c8692/src/airfoils.jl#L679-L694">source</a></section></article><p>Two provided corrections are Prandtl tip loss, and Prandtl tip and hub loss.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CCBlade.PrandtlTip" href="#CCBlade.PrandtlTip"><code>CCBlade.PrandtlTip</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PrandtlTip()</code></pre><p>Standard Prandtl tip loss correction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/CCBlade.jl/blob/a7704cb3c6e71f21acf7ac6c1d3eb4a6f64c8692/src/airfoils.jl#L699-L703">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CCBlade.PrandtlTipHub" href="#CCBlade.PrandtlTipHub"><code>CCBlade.PrandtlTipHub</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PrandtlTipHub()</code></pre><p>Standard Prandtl tip loss correction plus hub loss correction of same form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/CCBlade.jl/blob/a7704cb3c6e71f21acf7ac6c1d3eb4a6f64c8692/src/airfoils.jl#L706-L710">source</a></section></article><h2 id="Airfoil-Extrapolation"><a class="docs-heading-anchor" href="#Airfoil-Extrapolation">Airfoil Extrapolation</a><a id="Airfoil-Extrapolation-1"></a><a class="docs-heading-anchor-permalink" href="#Airfoil-Extrapolation" title="Permalink"></a></h2><p>While not used in CCBlade directly, for convenience a preprocessing method is provided to extrapolate airfoil coefficient data from <span>$-\pi$</span> to <span>$\pi$</span>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CCBlade.viterna" href="#CCBlade.viterna"><code>CCBlade.viterna</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">viterna(alpha, cl, cd, cr75, nalpha=50)</code></pre><p>Viterna extrapolation.  Follows Viterna paper and somewhat follows NREL version of AirfoilPrep, but with some modifications for better robustness and smoothness.</p><p><strong>Arguments</strong></p><ul><li><code>alpha::Vector{Float64}</code>: angles of attack</li><li><code>cl::Vector{Float64}</code>: correspnding lift coefficients</li><li><code>cd::Vector{Float64}</code>: correspnding drag coefficients</li><li><code>cr75::Float64</code>: chord/Rtip at 75% Rtip</li><li><code>nalpha::Int64</code>: number of discrete points (angles of attack) to include in extrapolation</li></ul><p><strong>Returns</strong></p><ul><li><code>alpha::Vector{Float64}</code>: angle of attack from -pi to pi</li><li><code>cl::Vector{Float64}</code>: correspnding extrapolated lift coefficients</li><li><code>cd::Vector{Float64}</code>: correspnding extrapolated drag coefficients</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/CCBlade.jl/blob/a7704cb3c6e71f21acf7ac6c1d3eb4a6f64c8692/src/airfoils.jl#L737-L753">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../howto/">« Guided Examples</a><a class="docs-footer-nextpage" href="../theory/">Theory »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Saturday 14 June 2025 01:46">Saturday 14 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
