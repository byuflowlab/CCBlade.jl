var documenterSearchIndex = {"docs":
[{"location":"howto/#Guided-Examples","page":"Guided Examples","title":"Guided Examples","text":"","category":"section"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"This section shows examples of how to perform various tasks in CCBlade.  It assumes familiarity with basic usage.","category":"page"},{"location":"howto/#Airfoil-Data","page":"Guided Examples","title":"Airfoil Data","text":"","category":"section"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"In this example we will construct an airfoil file.  In this case we are interested in the NACA 4412.  The XFOIL simulation data for this case is available here for (Re = 10^6).","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"using CCBlade\nusing PyPlot","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"\nxfoildata = [\n -14.000  -1.0990   0.02637   0.02282  -0.0871   0.9992   0.0166\n -13.750  -1.0711   0.02533   0.02165  -0.0885   0.9979   0.0170\n -13.500  -1.0462   0.02365   0.01985  -0.0903   0.9963   0.0177\n -13.250  -1.0163   0.02288   0.01905  -0.0918   0.9951   0.0183\n -13.000  -0.9847   0.02237   0.01850  -0.0933   0.9943   0.0189\n -12.750  -0.9549   0.02183   0.01790  -0.0943   0.9930   0.0195\n -12.500  -0.9260   0.02126   0.01724  -0.0952   0.9911   0.0201\n -12.250  -0.8954   0.02078   0.01666  -0.0963   0.9894   0.0206\n -12.000  -0.8682   0.01946   0.01525  -0.0976   0.9877   0.0214\n -11.750  -0.8365   0.01894   0.01471  -0.0990   0.9866   0.0220\n -11.500  -0.8038   0.01852   0.01424  -0.1004   0.9857   0.0227\n -11.250  -0.7707   0.01808   0.01375  -0.1019   0.9849   0.0235\n -11.000  -0.7369   0.01769   0.01328  -0.1035   0.9843   0.0242\n -10.750  -0.7070   0.01745   0.01297  -0.1041   0.9819   0.0246\n -10.500  -0.6803   0.01619   0.01161  -0.1049   0.9793   0.0257\n -10.250  -0.6491   0.01569   0.01109  -0.1060   0.9775   0.0264\n -10.000  -0.6172   0.01529   0.01065  -0.1071   0.9759   0.0271\n  -9.750  -0.5850   0.01491   0.01022  -0.1082   0.9742   0.0279\n  -9.500  -0.5547   0.01456   0.00981  -0.1089   0.9718   0.0287\n  -9.250  -0.5287   0.01426   0.00944  -0.1085   0.9665   0.0292\n  -9.000  -0.5023   0.01345   0.00855  -0.1085   0.9622   0.0299\n  -8.750  -0.4769   0.01285   0.00791  -0.1082   0.9574   0.0309\n  -8.500  -0.4513   0.01249   0.00752  -0.1078   0.9519   0.0317\n  -8.250  -0.4243   0.01214   0.00713  -0.1076   0.9474   0.0324\n  -8.000  -0.3979   0.01184   0.00678  -0.1073   0.9422   0.0333\n  -7.750  -0.3715   0.01155   0.00644  -0.1070   0.9363   0.0340\n  -7.500  -0.3442   0.01127   0.00609  -0.1068   0.9313   0.0345\n  -7.250  -0.3183   0.01080   0.00556  -0.1064   0.9249   0.0354\n  -7.000  -0.2921   0.01033   0.00505  -0.1061   0.9186   0.0365\n  -6.750  -0.2649   0.01003   0.00471  -0.1059   0.9125   0.0375\n  -6.500  -0.2377   0.00977   0.00441  -0.1057   0.9053   0.0384\n  -6.000  -0.1825   0.00935   0.00389  -0.1054   0.8910   0.0404\n  -5.750  -0.1549   0.00912   0.00360  -0.1052   0.8835   0.0414\n  -5.500  -0.1275   0.00880   0.00325  -0.1051   0.8751   0.0435\n  -5.000  -0.0718   0.00845   0.00283  -0.1049   0.8578   0.0476\n  -4.750  -0.0441   0.00824   0.00259  -0.1047   0.8488   0.0519\n  -4.500  -0.0162   0.00810   0.00243  -0.1046   0.8388   0.0569\n  -4.250   0.0117   0.00793   0.00228  -0.1045   0.8288   0.0655\n  -4.000   0.0394   0.00780   0.00213  -0.1044   0.8184   0.0745\n  -3.750   0.0674   0.00769   0.00201  -0.1044   0.8073   0.0820\n  -3.500   0.0954   0.00761   0.00191  -0.1043   0.7964   0.0890\n  -3.250   0.1232   0.00752   0.00180  -0.1042   0.7851   0.0977\n  -3.000   0.1512   0.00745   0.00171  -0.1041   0.7733   0.1066\n  -2.750   0.1791   0.00737   0.00163  -0.1040   0.7616   0.1182\n  -2.500   0.2069   0.00729   0.00156  -0.1040   0.7497   0.1332\n  -2.250   0.2346   0.00723   0.00150  -0.1039   0.7378   0.1502\n  -2.000   0.2625   0.00715   0.00145  -0.1038   0.7254   0.1697\n  -1.750   0.2903   0.00709   0.00142  -0.1038   0.7132   0.1927\n  -1.500   0.3180   0.00703   0.00141  -0.1037   0.7012   0.2214\n  -1.250   0.3456   0.00701   0.00139  -0.1036   0.6886   0.2466\n  -1.000   0.3734   0.00697   0.00138  -0.1035   0.6754   0.2686\n  -0.750   0.4012   0.00694   0.00137  -0.1035   0.6626   0.2903\n  -0.500   0.4288   0.00691   0.00138  -0.1034   0.6497   0.3203\n  -0.250   0.4562   0.00686   0.00139  -0.1033   0.6365   0.3629\n   0.000   0.4833   0.00678   0.00141  -0.1032   0.6232   0.4192\n   0.250   0.5102   0.00658   0.00146  -0.1031   0.6101   0.5177\n   0.500   0.5366   0.00635   0.00153  -0.1029   0.5975   0.6393\n   0.750   0.5622   0.00617   0.00160  -0.1024   0.5856   0.7449\n   1.000   0.5842   0.00594   0.00170  -0.1009   0.5740   0.8717\n   1.250   0.6163   0.00588   0.00177  -0.1014   0.5622   0.9842\n   1.500   0.6525   0.00598   0.00181  -0.1033   0.5505   1.0000\n   1.750   0.6788   0.00611   0.00186  -0.1029   0.5398   1.0000\n   2.000   0.7055   0.00622   0.00192  -0.1026   0.5294   1.0000\n   2.250   0.7325   0.00633   0.00199  -0.1024   0.5204   1.0000\n   2.500   0.7592   0.00646   0.00206  -0.1022   0.5112   1.0000\n   2.750   0.7865   0.00656   0.00213  -0.1020   0.5029   1.0000\n   3.250   0.8405   0.00681   0.00231  -0.1016   0.4847   1.0000\n   3.500   0.8672   0.00696   0.00240  -0.1014   0.4746   1.0000\n   3.750   0.8941   0.00709   0.00250  -0.1012   0.4646   1.0000\n   4.000   0.9210   0.00722   0.00260  -0.1010   0.4540   1.0000\n   4.250   0.9473   0.00739   0.00272  -0.1007   0.4426   1.0000\n   4.500   0.9734   0.00758   0.00284  -0.1004   0.4273   1.0000\n   4.750   0.9993   0.00778   0.00297  -0.1001   0.4110   1.0000\n   5.000   1.0254   0.00797   0.00311  -0.0998   0.3979   1.0000\n   5.250   1.0518   0.00813   0.00326  -0.0995   0.3861   1.0000\n   5.500   1.0777   0.00834   0.00342  -0.0992   0.3731   1.0000\n   5.750   1.1031   0.00857   0.00359  -0.0988   0.3575   1.0000\n   6.000   1.1280   0.00884   0.00379  -0.0983   0.3398   1.0000\n   6.250   1.1523   0.00914   0.00401  -0.0978   0.3207   1.0000\n   6.500   1.1761   0.00948   0.00426  -0.0971   0.2993   1.0000\n   6.750   1.1988   0.00989   0.00455  -0.0963   0.2737   1.0000\n   7.000   1.2208   0.01036   0.00488  -0.0954   0.2461   1.0000\n   7.250   1.2417   0.01089   0.00526  -0.0943   0.2173   1.0000\n   7.500   1.2614   0.01149   0.00569  -0.0931   0.1865   1.0000\n   7.750   1.2793   0.01220   0.00621  -0.0915   0.1526   1.0000\n   8.000   1.2973   0.01288   0.00672  -0.0900   0.1252   1.0000\n   8.250   1.3164   0.01345   0.00719  -0.0887   0.1065   1.0000\n   8.500   1.3346   0.01404   0.00769  -0.0872   0.0893   1.0000\n   8.750   1.3514   0.01469   0.00823  -0.0854   0.0729   1.0000\n   9.000   1.3676   0.01527   0.00875  -0.0836   0.0622   1.0000\n   9.250   1.3835   0.01581   0.00926  -0.0817   0.0563   1.0000\n   9.500   1.4004   0.01631   0.00976  -0.0799   0.0521   1.0000\n   9.750   1.4171   0.01682   0.01028  -0.0782   0.0491   1.0000\n  10.000   1.4317   0.01746   0.01091  -0.0762   0.0459   1.0000\n  10.250   1.4484   0.01797   0.01147  -0.0746   0.0442   1.0000\n  10.500   1.4653   0.01849   0.01203  -0.0731   0.0427   1.0000\n  10.750   1.4805   0.01911   0.01267  -0.0714   0.0411   1.0000\n  11.000   1.4938   0.01986   0.01343  -0.0695   0.0392   1.0000\n  11.250   1.5061   0.02069   0.01430  -0.0676   0.0376   1.0000\n  11.500   1.5221   0.02129   0.01495  -0.0662   0.0368   1.0000\n  11.750   1.5369   0.02199   0.01570  -0.0647   0.0356   1.0000\n  12.000   1.5500   0.02282   0.01656  -0.0631   0.0343   1.0000\n  12.250   1.5608   0.02382   0.01758  -0.0614   0.0330   1.0000\n  12.500   1.5688   0.02506   0.01888  -0.0594   0.0316   1.0000\n  12.750   1.5831   0.02588   0.01975  -0.0582   0.0308   1.0000\n  13.000   1.5959   0.02683   0.02075  -0.0569   0.0298   1.0000\n  13.250   1.6066   0.02796   0.02192  -0.0555   0.0286   1.0000\n  13.500   1.6141   0.02939   0.02338  -0.0540   0.0273   1.0000\n  13.750   1.6213   0.03089   0.02494  -0.0526   0.0262   1.0000\n  14.000   1.6325   0.03209   0.02620  -0.0516   0.0252   1.0000\n  14.250   1.6414   0.03354   0.02770  -0.0505   0.0241   1.0000\n  14.500   1.6474   0.03528   0.02947  -0.0493   0.0229   1.0000\n  14.750   1.6508   0.03731   0.03156  -0.0482   0.0218   1.0000\n  15.000   1.6585   0.03899   0.03332  -0.0474   0.0209   1.0000\n  15.250   1.6638   0.04096   0.03533  -0.0466   0.0198   1.0000\n  15.500   1.6661   0.04330   0.03772  -0.0458   0.0187   1.0000\n  15.750   1.6666   0.04589   0.04037  -0.0451   0.0179   1.0000\n  16.000   1.6698   0.04827   0.04284  -0.0447   0.0171   1.0000\n  16.250   1.6706   0.05099   0.04562  -0.0443   0.0164   1.0000\n  16.500   1.6692   0.05402   0.04871  -0.0440   0.0157   1.0000\n  16.750   1.6638   0.05759   0.05235  -0.0439   0.0151   1.0000\n  17.000   1.6605   0.06101   0.05587  -0.0439   0.0146   1.0000\n  17.250   1.6584   0.06435   0.05931  -0.0441   0.0142   1.0000\n  17.500   1.6548   0.06793   0.06298  -0.0444   0.0138   1.0000\n  17.750   1.6497   0.07175   0.06689  -0.0448   0.0134   1.0000\n  18.000   1.6430   0.07583   0.07106  -0.0453   0.0131   1.0000\n  18.250   1.6346   0.08024   0.07555  -0.0461   0.0128   1.0000\n  18.500   1.6237   0.08507   0.08047  -0.0470   0.0124   1.0000\n  18.750   1.6097   0.09040   0.08590  -0.0482   0.0121   1.0000\n]\n\nalpha_0 = xfoildata[:, 1] * pi/180\ncl_0 = xfoildata[:, 2]\ncd_0 = xfoildata[:, 3]","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"figure()\nplot(alpha_0, cl_0)\nxlabel(L\"\\alpha\")\nylabel(L\"c_l\")\nsavefig(\"cl1.svg\")\n\nfigure()\nplot(alpha_0, cd_0)\nxlabel(L\"\\alpha\")\nylabel(L\"c_d\")\nsavefig(\"cd1.svg\")","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"(Image: ) (Image: )","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"We now need to extrapolate the data to higher angles of attack.  Even though the propeller/turbine operation might not operate outside of these angles, the solver often needs to evaluate a range of angles during the solution process so it is helpful to provide data from -pi to pi.  We will use the Viterna extrapolation, and for that we just need to know the nondimensional chord ratio (chord/R) at 75% radius.  We will use the values for the APC thin electric 10 x 5 propeller that we used in the first tutorial.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"# ---- extrapolate ------\ncr75 = 0.128\nalpha_ext, cl_ext, cd_ext = viterna(alpha_0, cl_0, cd_0, cr75)","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"figure()\nplot(alpha_ext, cl_ext)\nxlabel(L\"\\alpha\")\nylabel(L\"c_l\")\nsavefig(\"cl2.svg\")\n\nfigure()\nplot(alpha_ext, cd_ext)\nxlabel(L\"\\alpha\")\nylabel(L\"c_d\")\nsavefig(\"cd2.svg\")","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"(Image: ) (Image: )","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Now we need to add various corrections.  These can either be done beforehand, or they can be evaluated on the fly.  In general one needs corrections for rotation (three-dimensional stall delay), Reynolds number, and Mach number.  The most accurate approach is to precompute the variation in Reynolds and Mach number and to evaluate rotation corrections on the fly.  However, all three can be done in any combination of precomputing or on-the-fly.  For the example we will start with the most accurate case (precompute Re/Mach and on-the-fly rotation), but will show the other variations as well.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"To address Reynolds number and Mach number variations beforehand we create 2D or 3D splines.  CCBlade provides helper functions for those scenarios.  The process is the same for Reynolds number and Mach number, and because the Mach number variation is not significant for this small propeller we will ignore it and focus just on Reynolds number.  For Reynolds number variation we would repeat the above process at multiple Reynolds numbers.  In this example we will use three different Reynolds numbers.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"# data previously computed for Re = 1e6, renaming for convenience\nalpha3, cl3, cd3 = alpha_ext, cl_ext, cd_ext\n\n# ---- Re = 5e5 ------\nxfoildata2 = [\n -12.250  -0.8284   0.04176   0.03861  -0.0832   1.0000   0.0246\n -12.000  -0.8522   0.03908   0.03574  -0.0799   1.0000   0.0247\n -11.750  -0.8699   0.03540   0.03185  -0.0776   0.9997   0.0251\n -11.500  -0.8415   0.03435   0.03082  -0.0796   0.9977   0.0258\n -11.250  -0.8114   0.03347   0.02989  -0.0818   0.9957   0.0265\n -11.000  -0.7822   0.03202   0.02830  -0.0843   0.9939   0.0275\n -10.750  -0.7591   0.02982   0.02579  -0.0862   0.9905   0.0285\n -10.500  -0.7309   0.02822   0.02384  -0.0882   0.9877   0.0293\n -10.250  -0.7053   0.02556   0.02100  -0.0903   0.9856   0.0304\n -10.000  -0.6714   0.02497   0.02039  -0.0924   0.9843   0.0314\n  -9.750  -0.6435   0.02420   0.01952  -0.0932   0.9807   0.0325\n  -9.500  -0.6134   0.02311   0.01823  -0.0945   0.9778   0.0336\n  -9.250  -0.5802   0.02227   0.01716  -0.0962   0.9758   0.0345\n  -9.000  -0.5492   0.02031   0.01504  -0.0982   0.9742   0.0359\n  -8.750  -0.5132   0.01962   0.01432  -0.1004   0.9731   0.0371\n  -8.500  -0.4849   0.01894   0.01355  -0.1008   0.9683   0.0381\n  -8.250  -0.4502   0.01823   0.01273  -0.1025   0.9656   0.0394\n  -8.000  -0.4135   0.01756   0.01192  -0.1045   0.9637   0.0405\n  -7.750  -0.3794   0.01639   0.01059  -0.1062   0.9619   0.0416\n  -7.500  -0.3455   0.01547   0.00965  -0.1078   0.9602   0.0430\n  -7.250  -0.3201   0.01501   0.00917  -0.1073   0.9539   0.0442\n  -7.000  -0.2893   0.01445   0.00854  -0.1080   0.9502   0.0454\n  -6.750  -0.2573   0.01389   0.00791  -0.1088   0.9471   0.0467\n  -6.500  -0.2303   0.01351   0.00746  -0.1085   0.9415   0.0478\n  -6.250  -0.2035   0.01278   0.00668  -0.1083   0.9357   0.0494\n  -6.000  -0.1743   0.01225   0.00613  -0.1085   0.9314   0.0512\n  -5.750  -0.1485   0.01190   0.00577  -0.1080   0.9242   0.0529\n  -5.500  -0.1206   0.01155   0.00536  -0.1078   0.9180   0.0550\n  -5.250  -0.0931   0.01118   0.00493  -0.1076   0.9117   0.0575\n  -5.000  -0.0666   0.01079   0.00457  -0.1072   0.9038   0.0614\n  -4.750  -0.0382   0.01055   0.00427  -0.1071   0.8974   0.0656\n  -4.500  -0.0118   0.01018   0.00393  -0.1067   0.8884   0.0727\n  -4.250   0.0161   0.00990   0.00363  -0.1066   0.8810   0.0812\n  -4.000   0.0434   0.00973   0.00343  -0.1063   0.8716   0.0897\n  -3.750   0.0710   0.00948   0.00321  -0.1061   0.8628   0.1006\n  -3.500   0.0987   0.00929   0.00301  -0.1060   0.8534   0.1110\n  -3.250   0.1262   0.00913   0.00285  -0.1058   0.8432   0.1221\n  -3.000   0.1541   0.00898   0.00269  -0.1056   0.8335   0.1353\n  -2.750   0.1815   0.00882   0.00255  -0.1054   0.8224   0.1520\n  -2.500   0.2090   0.00867   0.00244  -0.1053   0.8113   0.1733\n  -2.250   0.2366   0.00855   0.00235  -0.1051   0.8004   0.1993\n  -2.000   0.2641   0.00844   0.00229  -0.1049   0.7887   0.2300\n  -1.750   0.2915   0.00833   0.00224  -0.1048   0.7765   0.2579\n  -1.500   0.3190   0.00826   0.00218  -0.1046   0.7645   0.2832\n  -1.250   0.3463   0.00818   0.00213  -0.1044   0.7525   0.3117\n  -1.000   0.3734   0.00807   0.00209  -0.1042   0.7397   0.3503\n  -0.750   0.4003   0.00792   0.00208  -0.1040   0.7267   0.4055\n  -0.500   0.4265   0.00766   0.00208  -0.1038   0.7141   0.5024\n  -0.250   0.4513   0.00733   0.00214  -0.1031   0.7014   0.6445\n   0.000   0.4741   0.00703   0.00220  -0.1018   0.6886   0.7752\n   0.250   0.4944   0.00681   0.00229  -0.0995   0.6757   0.9086\n   0.500   0.5429   0.00683   0.00228  -0.1037   0.6616   0.9948\n   0.750   0.5727   0.00693   0.00228  -0.1041   0.6484   1.0000\n   1.000   0.5983   0.00705   0.00231  -0.1035   0.6356   1.0000\n   1.250   0.6239   0.00719   0.00235  -0.1030   0.6230   1.0000\n   1.500   0.6499   0.00731   0.00240  -0.1026   0.6104   1.0000\n   1.750   0.6761   0.00744   0.00246  -0.1022   0.5984   1.0000\n   2.000   0.7023   0.00759   0.00253  -0.1018   0.5871   1.0000\n   2.250   0.7283   0.00775   0.00260  -0.1014   0.5758   1.0000\n   2.500   0.7548   0.00788   0.00269  -0.1011   0.5646   1.0000\n   2.750   0.7811   0.00804   0.00279  -0.1007   0.5544   1.0000\n   3.000   0.8073   0.00820   0.00290  -0.1004   0.5444   1.0000\n   3.250   0.8339   0.00834   0.00302  -0.1001   0.5349   1.0000\n   3.500   0.8600   0.00854   0.00314  -0.0998   0.5260   1.0000\n   3.750   0.8867   0.00866   0.00327  -0.0995   0.5166   1.0000\n   4.000   0.9127   0.00884   0.00341  -0.0992   0.5067   1.0000\n   4.250   0.9385   0.00902   0.00355  -0.0988   0.4957   1.0000\n   4.500   0.9647   0.00917   0.00370  -0.0984   0.4849   1.0000\n   4.750   0.9903   0.00937   0.00385  -0.0980   0.4741   1.0000\n   5.000   1.0155   0.00957   0.00400  -0.0975   0.4618   1.0000\n   5.250   1.0403   0.00977   0.00416  -0.0970   0.4460   1.0000\n   5.500   1.0652   0.00997   0.00433  -0.0964   0.4309   1.0000\n   5.750   1.0906   0.01016   0.00452  -0.0960   0.4187   1.0000\n   6.000   1.1155   0.01038   0.00472  -0.0955   0.4067   1.0000\n   6.250   1.1399   0.01063   0.00495  -0.0949   0.3935   1.0000\n   6.500   1.1639   0.01090   0.00518  -0.0942   0.3784   1.0000\n   6.750   1.1875   0.01119   0.00543  -0.0935   0.3609   1.0000\n   7.000   1.2103   0.01152   0.00571  -0.0927   0.3410   1.0000\n   7.250   1.2318   0.01193   0.00603  -0.0917   0.3191   1.0000\n   7.500   1.2528   0.01238   0.00639  -0.0906   0.2935   1.0000\n   7.750   1.2718   0.01294   0.00682  -0.0892   0.2643   1.0000\n   8.000   1.2891   0.01362   0.00734  -0.0876   0.2320   1.0000\n   8.250   1.3042   0.01442   0.00794  -0.0856   0.1973   1.0000\n   8.500   1.3175   0.01531   0.00862  -0.0834   0.1607   1.0000\n   8.750   1.3282   0.01622   0.00934  -0.0807   0.1301   1.0000\n   9.000   1.3388   0.01711   0.01011  -0.0781   0.1080   1.0000\n   9.250   1.3500   0.01798   0.01089  -0.0756   0.0904   1.0000\n   9.500   1.3615   0.01884   0.01169  -0.0732   0.0782   1.0000\n   9.750   1.3735   0.01968   0.01251  -0.0709   0.0704   1.0000\n  10.000   1.3845   0.02060   0.01340  -0.0687   0.0648   1.0000\n  10.250   1.3969   0.02144   0.01429  -0.0667   0.0610   1.0000\n  10.500   1.4094   0.02230   0.01519  -0.0648   0.0580   1.0000\n  10.750   1.4184   0.02340   0.01630  -0.0626   0.0550   1.0000\n  11.000   1.4270   0.02457   0.01753  -0.0605   0.0528   1.0000\n  11.250   1.4395   0.02551   0.01855  -0.0589   0.0510   1.0000\n  11.500   1.4503   0.02659   0.01969  -0.0573   0.0492   1.0000\n  11.750   1.4584   0.02791   0.02104  -0.0555   0.0473   1.0000\n  12.000   1.4602   0.02976   0.02294  -0.0533   0.0455   1.0000\n  12.250   1.4688   0.03116   0.02443  -0.0519   0.0443   1.0000\n  12.500   1.4791   0.03246   0.02581  -0.0507   0.0429   1.0000\n  12.750   1.4875   0.03395   0.02738  -0.0495   0.0414   1.0000\n  13.000   1.4938   0.03568   0.02917  -0.0483   0.0400   1.0000\n  13.250   1.4941   0.03801   0.03154  -0.0469   0.0387   1.0000\n  13.500   1.4941   0.04045   0.03407  -0.0457   0.0375   1.0000\n  13.750   1.5030   0.04212   0.03584  -0.0450   0.0363   1.0000\n  14.000   1.5091   0.04410   0.03790  -0.0444   0.0349   1.0000\n  14.250   1.5135   0.04630   0.04017  -0.0438   0.0337   1.0000\n  14.500   1.5126   0.04913   0.04305  -0.0432   0.0326   1.0000\n  14.750   1.5064   0.05260   0.04659  -0.0426   0.0315   1.0000\n  15.000   1.5124   0.05486   0.04898  -0.0424   0.0305   1.0000\n  15.250   1.5153   0.05748   0.05169  -0.0423   0.0294   1.0000\n  15.500   1.5171   0.06031   0.05459  -0.0423   0.0283   1.0000\n  15.750   1.5155   0.06359   0.05793  -0.0425   0.0274   1.0000\n  16.000   1.5055   0.06789   0.06228  -0.0426   0.0265   1.0000\n  16.250   1.5080   0.07082   0.06534  -0.0429   0.0257   1.0000\n  16.500   1.5081   0.07407   0.06871  -0.0433   0.0248   1.0000\n  16.750   1.5068   0.07756   0.07229  -0.0439   0.0240   1.0000\n  17.000   1.5043   0.08125   0.07605  -0.0445   0.0233   1.0000\n  17.250   1.4987   0.08538   0.08024  -0.0453   0.0226   1.0000\n]\n\nalpha = xfoildata2[:, 1] * pi/180\ncl = xfoildata2[:, 2]\ncd = xfoildata2[:, 3]\n\nalpha2, cl2, cd2 = viterna(alpha, cl, cd, cr75)\n\n# ------ Re = 2e5 ---------\nxfoildata1 = [\n  -8.500  -0.4088   0.08983   0.08647  -0.0344   1.0000   0.0813\n  -8.250  -0.4231   0.08831   0.08501  -0.0315   1.0000   0.0823\n  -8.000  -0.4442   0.08695   0.08373  -0.0282   1.0000   0.0831\n  -7.750  -0.4937   0.05313   0.04929  -0.0671   0.9865   0.0673\n  -7.500  -0.4712   0.04655   0.04243  -0.0720   0.9817   0.0641\n  -7.250  -0.4535   0.03731   0.03244  -0.0777   0.9755   0.0622\n  -7.000  -0.4231   0.03226   0.02667  -0.0816   0.9717   0.0637\n  -6.750  -0.3952   0.02910   0.02295  -0.0831   0.9655   0.0647\n  -6.500  -0.3582   0.02703   0.02031  -0.0857   0.9620   0.0660\n  -6.250  -0.3204   0.02462   0.01772  -0.0887   0.9600   0.0684\n  -6.000  -0.2930   0.02357   0.01656  -0.0890   0.9523   0.0702\n  -5.750  -0.2544   0.02238   0.01517  -0.0913   0.9489   0.0725\n  -5.500  -0.2129   0.02134   0.01390  -0.0940   0.9465   0.0756\n  -5.250  -0.1843   0.02032   0.01270  -0.0942   0.9393   0.0785\n  -5.000  -0.1466   0.01934   0.01174  -0.0963   0.9352   0.0824\n  -4.750  -0.1047   0.01855   0.01086  -0.0990   0.9326   0.0877\n  -4.500  -0.0618   0.01758   0.00989  -0.1020   0.9308   0.0951\n  -4.250  -0.0351   0.01719   0.00943  -0.1016   0.9217   0.1030\n  -4.000   0.0030   0.01638   0.00871  -0.1036   0.9180   0.1150\n  -3.750   0.0426   0.01571   0.00806  -0.1058   0.9151   0.1299\n  -3.500   0.0687   0.01531   0.00771  -0.1053   0.9057   0.1437\n  -3.250   0.1047   0.01477   0.00720  -0.1066   0.9011   0.1620\n  -3.000   0.1342   0.01437   0.00686  -0.1068   0.8934   0.1821\n  -2.750   0.1659   0.01392   0.00653  -0.1073   0.8865   0.2077\n  -2.500   0.1964   0.01352   0.00623  -0.1075   0.8792   0.2377\n  -2.250   0.2255   0.01312   0.00593  -0.1075   0.8706   0.2707\n  -2.000   0.2541   0.01274   0.00566  -0.1074   0.8618   0.3065\n  -1.750   0.2836   0.01233   0.00537  -0.1074   0.8533   0.3489\n  -1.500   0.3098   0.01195   0.00520  -0.1069   0.8424   0.4005\n  -1.250   0.3373   0.01136   0.00499  -0.1066   0.8336   0.5000\n  -1.000   0.3583   0.01070   0.00498  -0.1046   0.8222   0.6832\n  -0.500   0.4431   0.00999   0.00468  -0.1085   0.8021   1.0000\n  -0.250   0.4683   0.01000   0.00456  -0.1077   0.7890   1.0000\n   0.000   0.4938   0.01005   0.00448  -0.1071   0.7758   1.0000\n   0.250   0.5198   0.01011   0.00441  -0.1065   0.7629   1.0000\n   0.500   0.5464   0.01019   0.00435  -0.1060   0.7504   1.0000\n   0.750   0.5733   0.01027   0.00429  -0.1056   0.7383   1.0000\n   1.000   0.5988   0.01039   0.00431  -0.1050   0.7246   1.0000\n   1.250   0.6247   0.01052   0.00435  -0.1045   0.7115   1.0000\n   1.500   0.6510   0.01066   0.00439  -0.1040   0.6992   1.0000\n   1.750   0.6778   0.01082   0.00443  -0.1036   0.6876   1.0000\n   2.000   0.7038   0.01097   0.00451  -0.1032   0.6752   1.0000\n   2.250   0.7297   0.01115   0.00463  -0.1027   0.6629   1.0000\n   2.500   0.7561   0.01133   0.00474  -0.1023   0.6517   1.0000\n   2.750   0.7828   0.01152   0.00483  -0.1020   0.6409   1.0000\n   3.000   0.8084   0.01171   0.00500  -0.1014   0.6289   1.0000\n   3.250   0.8345   0.01191   0.00515  -0.1010   0.6180   1.0000\n   3.500   0.8613   0.01213   0.00528  -0.1007   0.6079   1.0000\n   3.750   0.8865   0.01233   0.00549  -0.1002   0.5965   1.0000\n   4.000   0.9127   0.01256   0.00569  -0.0998   0.5863   1.0000\n   4.250   0.9390   0.01280   0.00587  -0.0995   0.5765   1.0000\n   4.500   0.9643   0.01303   0.00613  -0.0990   0.5659   1.0000\n   4.750   0.9905   0.01330   0.00636  -0.0986   0.5563   1.0000\n   5.000   1.0156   0.01352   0.00657  -0.0980   0.5448   1.0000\n   5.250   1.0396   0.01373   0.00679  -0.0972   0.5317   1.0000\n   5.500   1.0639   0.01396   0.00701  -0.0965   0.5191   1.0000\n   5.750   1.0888   0.01422   0.00724  -0.0959   0.5080   1.0000\n   6.000   1.1122   0.01444   0.00743  -0.0950   0.4940   1.0000\n   6.250   1.1342   0.01464   0.00764  -0.0938   0.4781   1.0000\n   6.500   1.1562   0.01486   0.00788  -0.0927   0.4627   1.0000\n   6.750   1.1783   0.01510   0.00815  -0.0916   0.4482   1.0000\n   7.000   1.2002   0.01536   0.00845  -0.0905   0.4333   1.0000\n   7.250   1.2215   0.01565   0.00876  -0.0893   0.4177   1.0000\n   7.500   1.2420   0.01596   0.00908  -0.0880   0.4012   1.0000\n   7.750   1.2616   0.01630   0.00943  -0.0866   0.3835   1.0000\n   8.000   1.2799   0.01670   0.00982  -0.0849   0.3635   1.0000\n   8.250   1.2967   0.01714   0.01026  -0.0831   0.3392   1.0000\n   8.500   1.3110   0.01772   0.01076  -0.0809   0.3110   1.0000\n   8.750   1.3218   0.01847   0.01138  -0.0781   0.2773   1.0000\n   9.000   1.3267   0.01944   0.01217  -0.0745   0.2406   1.0000\n   9.250   1.3283   0.02069   0.01320  -0.0706   0.1997   1.0000\n   9.500   1.3275   0.02223   0.01449  -0.0667   0.1617   1.0000\n   9.750   1.3266   0.02391   0.01597  -0.0630   0.1356   1.0000\n  10.000   1.3275   0.02555   0.01752  -0.0598   0.1187   1.0000\n  10.250   1.3289   0.02726   0.01916  -0.0569   0.1080   1.0000\n  10.500   1.3326   0.02887   0.02077  -0.0544   0.1001   1.0000\n  10.750   1.3366   0.03055   0.02249  -0.0520   0.0942   1.0000\n  11.000   1.3429   0.03209   0.02408  -0.0501   0.0890   1.0000\n  11.250   1.3438   0.03415   0.02607  -0.0479   0.0848   1.0000\n  11.500   1.3530   0.03558   0.02764  -0.0464   0.0812   1.0000\n  11.750   1.3601   0.03722   0.02934  -0.0450   0.0776   1.0000\n  12.000   1.3641   0.03917   0.03125  -0.0433   0.0746   1.0000\n  12.250   1.3713   0.04092   0.03309  -0.0418   0.0719   1.0000\n  12.500   1.3790   0.04262   0.03491  -0.0407   0.0690   1.0000\n  12.750   1.3857   0.04441   0.03676  -0.0395   0.0664   1.0000\n  13.000   1.3923   0.04629   0.03859  -0.0382   0.0639   1.0000\n  13.250   1.4001   0.04814   0.04054  -0.0369   0.0616   1.0000\n  13.500   1.4059   0.05012   0.04268  -0.0360   0.0593   1.0000\n  13.750   1.4115   0.05212   0.04477  -0.0351   0.0571   1.0000\n  14.000   1.4180   0.05407   0.04670  -0.0342   0.0549   1.0000\n  14.250   1.4266   0.05607   0.04875  -0.0329   0.0527   1.0000\n  14.500   1.4286   0.05852   0.05141  -0.0322   0.0509   1.0000\n  14.750   1.4308   0.06101   0.05404  -0.0316   0.0491   1.0000\n  15.000   1.4342   0.06336   0.05644  -0.0312   0.0473   1.0000\n  15.250   1.4467   0.06514   0.05814  -0.0297   0.0450   1.0000\n  15.500   1.4416   0.06845   0.06172  -0.0297   0.0440   1.0000\n  15.750   1.4385   0.07175   0.06524  -0.0296   0.0427   1.0000\n  16.000   1.4362   0.07501   0.06865  -0.0296   0.0414   1.0000\n  16.250   1.4351   0.07813   0.07188  -0.0298   0.0401   1.0000\n  16.500   1.4392   0.08059   0.07434  -0.0296   0.0388   1.0000\n  16.750   1.4401   0.08377   0.07759  -0.0291   0.0376   1.0000\n  17.000   1.4274   0.08864   0.08274  -0.0304   0.0369   1.0000\n  17.250   1.4151   0.09369   0.08804  -0.0318   0.0363   1.0000\n]\n\nalpha = xfoildata1[:, 1] * pi/180\ncl = xfoildata1[:, 2]\ncd = xfoildata1[:, 3]\n\nalpha1, cl1, cd1 = viterna(alpha, cl, cd, cr75)\nnothing #hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"All the data must be the same angles of attack.  They are not in this case, so we need to interpolate the data onto a common set.  Next, we combine the cl and cd data into one matrix.  To do the interpolation we are going to use the FLOWMath package (which is already a dependency of CCBlade so should already be installed).","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"import FLOWMath\n\n# interpolate onto alpha1-\ncl2 = FLOWMath.linear(alpha2, cl2, alpha1)\ncd2 = FLOWMath.linear(alpha2, cd2, alpha1)\ncl3 = FLOWMath.linear(alpha3, cl3, alpha1)\ncd3 = FLOWMath.linear(alpha3, cd3, alpha1)\n\nalpha = alpha1\nRe = [2e5, 5e5, 1e6]\ncl = [cl1 cl2 cl3]  # cl[i, j] corresponds to alpha[i], Re[j]\ncd = [cd1 cd2 cd3]\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"We can load that data directly into an airfoil object for usage in CCBlade.  The airfoil object creates a smooth spline based on the data (an Akima spline, or recursive Akima splines in higher dimensions).","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"af = AlphaReAF(alpha, Re, cl, cd, \"NACA4412 (no rotation)\")\nnothing #hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"More commonly we first save it to a file so we don't have to repeat these calculations when we want to reuse this airfoil in future simulations.  We added the subscript norot in the file name just to remind ourselves that this data does not have rotational corrections.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"One file corresponds to one Reynolds number and one Mach number.  The file format first contains one header line.  That is just a convenience to provide information about the airfoil data.  The next line is the Reynolds number, and the next line is the Mach number.  The rest of the file contains data in columns split by whitespace (not commas) in the following order: alpha, cl, cd.  You can add additional columns of data (e.g., cm), but they will be ignored. For example, a simple file (a cylinder section) would look like:","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Cylinder section with a Cd of 0.50.  Re = 1 million.\n1e6\n0.0\n-180.0   0.000   0.5000   0.000\n0.00     0.000   0.5000   0.000\n180.0    0.000   0.5000   0.000","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"For this case we have three Reynolds numbers so we need to specify three file names.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"filenames = [\"naca4412_2e5_norot.dat\", \"naca4412_5e5_norot.dat\", \"naca4412_1e6_norot.dat\"]\nwrite_af(filenames, af)","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"To reload the data from file later we can use:","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"af2 = AlphaReAF(filenames, radians=true)  # angle of attack is given in radians in the file","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"To have CCBlade apply rotation corrections on the fly we need to choose a method.  We will use the Du-Selig correction for lift and the Eggers correction for drag.  We pass this into the rotation keyword on the Rotor struct.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Rtip = 10/2.0 * 0.0254  # inches to meters\nRhub = 0.10*Rtip\nB = 2  # number of blades\ndu = DuSeligEggers()\nrotor = Rotor(Rhub, Rtip, B, rotation=du)\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"In a similar way, if we didn't want to create 2D or 3D tables, we can compute Reynolds number and Mach number corrections on-the-fly by passing in the options re and mach respectively.  For example, let's say we only had the data for Re = 10^6 but we wanted to include some Reynolds number variation in our data.  We can use:","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Re0 = 1e6\nsf = TurbulentSkinFriction(Re0)\n\nrotor = Rotor(Rhub, Rtip, B, rotation=du, re=sf)\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"This method simply adjusts the drag coefficient based on flat plate skin friction formulas/fits.  A similar method exists for laminar flow LaminarSkinFriction or for a user-specified exponent SkinFriction.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"For Mach number the Prandtl-Glauert correction is available, which doesn't require any inputs.  This correction only affects the lift coefficient.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"pg = PrandtlGlauert()\nrotor = Rotor(Rhub, Rtip, B, rotation=du, re=sf, mach=pg)\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"These two methods are generally less accurate than providing data beforehand because the Reynolds number variation is just based of flat plate theory rather than the actual airfoil pressure distribution, and with a pressure distribution one can use the more accurate Karman-Tsien correction for Mach number variation.  However, the magnitude of these correction is usually very minor anyway, and so the extra complication of precomputing may not be justifiable.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"A user can easily define their own correction methods for rotation, Reynolds number, Mach number, and for tip-losses (the latter is for the blade not the airfoil).  This works based on dispatch. For example, let's say you wanted a Mach number correction that also affected drag with a simple transonic drag rise model.  First, you define your own struct as a subtype of the abstract type MachCorrection.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"struct TransonicDrag <: MachCorrection\n    Mcc  # crest critical Mach number\nend","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Then we overload the mach_correction function for this type.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"function mach_correction(td::TransonicDrag, cl, cd, Mach)\n    beta = sqrt(1 - Mach^2)\n    cl /= beta\n    cd += 20 * (Mach - td.Mcc)^4  # add estimate for compressibility drag\n    return cl, cd\nend\nnothing #hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Now we can initialize our struct and pass it in to the rotor.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Mcc = 0.65\ntd = TransonicDrag(Mcc)\nrotor = Rotor(Rhub, Rtip, B, rotation=du, re=sf, mach=td)\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"A similar procedure can be followed for any of the other correction methods.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"The last variation to consider is precomputing rotational corrections instead of  computing them on-the-fly.  While it might be more accurate to do them on-the-fly, the main advantage to precomputing everything is that we can inspect the airfoil data and make sure everything looks reasonable, and it is a bit more efficient.  This is the approach we use most frequently in optimization applications to ensure smooth input data.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"We will use the same airfoil (NACA 4412), but because we  reuse this data for the validation in the introductory tutorial, we will pick out a Reynolds number closer to that operating point.  At 70% radius the Reynolds number is about 60,000.  We will use this data at a Reynolds number of 50,000.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"data = [\n    -9.500  -0.3702   0.10257   0.09512  -0.0434   1.0000   0.0814\n    -9.250  -0.3756   0.09949   0.09212  -0.0434   1.0000   0.0818\n    -9.000  -0.3833   0.09645   0.08917  -0.0431   1.0000   0.0820\n    -8.750  -0.3944   0.09343   0.08625  -0.0427   1.0000   0.0820\n    -8.500  -0.4100   0.09047   0.08341  -0.0417   1.0000   0.0816\n    -8.250  -0.4299   0.08732   0.08039  -0.0409   1.0000   0.0810\n    -8.000  -0.4479   0.08303   0.07621  -0.0420   1.0000   0.0803\n    -7.750  -0.4686   0.07711   0.07032  -0.0448   1.0000   0.0792\n    -7.500  -0.4911   0.06887   0.06196  -0.0492   1.0000   0.0780\n    -7.250  -0.4987   0.06336   0.05627  -0.0508   1.0000   0.0779\n    -7.000  -0.4940   0.06087   0.05373  -0.0500   1.0000   0.0789\n    -6.750  -0.4877   0.05850   0.05127  -0.0495   1.0000   0.0805\n    -6.500  -0.4810   0.05518   0.04776  -0.0500   1.0000   0.0823\n    -6.250  -0.4717   0.05110   0.04334  -0.0512   1.0000   0.0841\n    -6.000  -0.4427   0.04575   0.03734  -0.0562   0.9950   0.0860\n    -5.750  -0.4092   0.04098   0.03168  -0.0608   0.9891   0.0892\n    -5.500  -0.3741   0.03906   0.02956  -0.0638   0.9834   0.0930\n    -5.250  -0.3400   0.03717   0.02734  -0.0662   0.9766   0.0971\n    -5.000  -0.3028   0.03484   0.02442  -0.0691   0.9709   0.1017\n    -4.750  -0.2684   0.03351   0.02292  -0.0712   0.9637   0.1074\n    -4.500  -0.2321   0.03231   0.02141  -0.0734   0.9571   0.1148\n    -4.250  -0.1973   0.03121   0.02015  -0.0752   0.9496   0.1223\n    -4.000  -0.1609   0.03030   0.01893  -0.0771   0.9427   0.1335\n    -3.750  -0.1273   0.02962   0.01828  -0.0786   0.9345   0.1451\n    -3.500  -0.0919   0.02897   0.01757  -0.0803   0.9272   0.1596\n    -3.250  -0.0582   0.02841   0.01695  -0.0816   0.9187   0.1764\n    -3.000  -0.0233   0.02793   0.01637  -0.0831   0.9109   0.1972\n    -2.750   0.0107   0.02748   0.01598  -0.0844   0.9023   0.2192\n    -2.500   0.0446   0.02706   0.01551  -0.0856   0.8938   0.2468\n    -2.250   0.0801   0.02658   0.01509  -0.0872   0.8857   0.2797\n    -2.000   0.1114   0.02617   0.01480  -0.0880   0.8763   0.3161\n    -1.750   0.1483   0.02563   0.01444  -0.0897   0.8691   0.3663\n    -1.500   0.1764   0.02515   0.01427  -0.0898   0.8589   0.4272\n    -1.250   0.2096   0.02431   0.01404  -0.0903   0.8522   0.5434\n    -1.000   0.2272   0.02363   0.01410  -0.0870   0.8414   0.7358\n    -0.750   0.2803   0.02308   0.01357  -0.0906   0.8353   1.0000\n    -0.500   0.3061   0.02323   0.01348  -0.0904   0.8230   1.0000\n    -0.250   0.3355   0.02334   0.01335  -0.0906   0.8126   1.0000\n     0.000   0.3708   0.02329   0.01309  -0.0917   0.8045   1.0000\n     0.250   0.3965   0.02348   0.01312  -0.0913   0.7926   1.0000\n     0.500   0.4283   0.02352   0.01300  -0.0918   0.7836   1.0000\n     0.750   0.4582   0.02360   0.01294  -0.0920   0.7736   1.0000\n     1.000   0.4847   0.02380   0.01304  -0.0917   0.7624   1.0000\n     1.250   0.5198   0.02372   0.01284  -0.0925   0.7549   1.0000\n     1.500   0.5435   0.02403   0.01307  -0.0918   0.7427   1.0000\n     1.750   0.5716   0.02420   0.01317  -0.0917   0.7328   1.0000\n     2.000   0.6027   0.02426   0.01315  -0.0919   0.7237   1.0000\n     2.250   0.6269   0.02460   0.01344  -0.0913   0.7123   1.0000\n     2.500   0.6593   0.02462   0.01341  -0.0917   0.7042   1.0000\n     2.750   0.6835   0.02497   0.01374  -0.0910   0.6928   1.0000\n     3.000   0.7090   0.02530   0.01406  -0.0905   0.6824   1.0000\n     3.250   0.7403   0.02537   0.01410  -0.0907   0.6739   1.0000\n     3.500   0.7624   0.02586   0.01461  -0.0898   0.6624   1.0000\n     3.750   0.7907   0.02608   0.01484  -0.0897   0.6532   1.0000\n     4.000   0.8168   0.02639   0.01517  -0.0892   0.6430   1.0000\n     4.250   0.8399   0.02687   0.01568  -0.0885   0.6322   1.0000\n     4.500   0.8722   0.02691   0.01573  -0.0887   0.6241   1.0000\n     4.750   0.8917   0.02754   0.01645  -0.0875   0.6123   1.0000\n     5.000   0.9163   0.02795   0.01691  -0.0868   0.6020   1.0000\n     5.250   0.9455   0.02813   0.01714  -0.0867   0.5927   1.0000\n     5.500   0.9652   0.02877   0.01788  -0.0855   0.5810   1.0000\n     5.750   0.9905   0.02913   0.01831  -0.0848   0.5707   1.0000\n     6.000   1.0175   0.02941   0.01867  -0.0844   0.5605   1.0000\n     6.250   1.0364   0.03007   0.01946  -0.0830   0.5485   1.0000\n     6.500   1.0604   0.03049   0.01997  -0.0822   0.5375   1.0000\n     6.750   1.0886   0.03065   0.02021  -0.0818   0.5267   1.0000\n     7.000   1.1063   0.03126   0.02095  -0.0801   0.5130   1.0000\n     7.250   1.1256   0.03166   0.02145  -0.0785   0.4982   1.0000\n     7.500   1.1446   0.03199   0.02187  -0.0767   0.4824   1.0000\n     7.750   1.1625   0.03233   0.02232  -0.0748   0.4661   1.0000\n     8.000   1.1790   0.03272   0.02281  -0.0728   0.4495   1.0000\n     8.250   1.1940   0.03312   0.02328  -0.0706   0.4319   1.0000\n     8.500   1.2081   0.03344   0.02364  -0.0681   0.4129   1.0000\n     8.750   1.2133   0.03423   0.02456  -0.0648   0.3924   1.0000\n     9.000   1.2172   0.03500   0.02539  -0.0614   0.3714   1.0000\n     9.250   1.2229   0.03574   0.02611  -0.0582   0.3496   1.0000\n     9.500   1.2242   0.03697   0.02742  -0.0551   0.3266   1.0000\n     9.750   1.2270   0.03817   0.02858  -0.0522   0.3030   1.0000\n    10.000   1.2268   0.03981   0.03022  -0.0495   0.2781   1.0000\n    10.250   1.2259   0.04163   0.03197  -0.0470   0.2536   1.0000\n    10.500   1.2235   0.04380   0.03406  -0.0448   0.2301   1.0000\n    10.750   1.2203   0.04622   0.03636  -0.0428   0.2093   1.0000\n    11.000   1.2168   0.04888   0.03897  -0.0412   0.1904   1.0000\n    11.250   1.2134   0.05168   0.04171  -0.0398   0.1746   1.0000\n    11.500   1.2106   0.05454   0.04452  -0.0386   0.1616   1.0000\n    11.750   1.2084   0.05742   0.04733  -0.0375   0.1507   1.0000\n    12.000   1.2078   0.06025   0.05018  -0.0366   0.1408   1.0000\n    12.250   1.2092   0.06297   0.05295  -0.0357   0.1324   1.0000\n    12.500   1.2115   0.06552   0.05546  -0.0348   0.1256   1.0000\n    12.750   1.2154   0.06813   0.05820  -0.0340   0.1188   1.0000\n    13.000   1.2196   0.07058   0.06067  -0.0332   0.1129   1.0000\n    13.250   1.2253   0.07302   0.06320  -0.0324   0.1078   1.0000\n    13.500   1.2306   0.07564   0.06601  -0.0318   0.1031   1.0000\n    13.750   1.2392   0.07769   0.06807  -0.0309   0.0988   1.0000\n    14.000   1.2432   0.08059   0.07115  -0.0305   0.0950   1.0000\n    14.250   1.2420   0.08420   0.07504  -0.0306   0.0916   1.0000\n    14.500   1.2438   0.08737   0.07836  -0.0305   0.0885   1.0000\n    14.750   1.2590   0.08867   0.07955  -0.0294   0.0849   1.0000\n    15.000   1.2455   0.09415   0.08542  -0.0307   0.0832   1.0000\n    15.250   1.2309   0.10003   0.09162  -0.0325   0.0815   1.0000\n    15.500   1.2146   0.10644   0.09830  -0.0349   0.0800   1.0000\n    15.750   1.1958   0.11362   0.10573  -0.0381   0.0788   1.0000\n    16.000   1.1706   0.12256   0.11492  -0.0427   0.0781   1.0000\n    16.250   1.1230   0.13766   0.13029  -0.0518   0.0786   1.0000\n]\n\nalpha_0 = data[:, 1] * pi/180\ncl_0 = data[:, 2]\ncd_0 = data[:, 3]\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Next, we extrapolate","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"cr75 = 0.128\nalpha_ext, cl_ext, cd_ext = viterna(alpha_0, cl_0, cd_0, cr75)\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Now we can apply the rotational corrections.  Most rotational correction methods require some nondimensional geometric and operational data (usually r/R, c/R, and tip-speed ratio).  Because we are doing this beforehand we don't know where on the blade we will evaluate, so we just have to pick some representative location, and some representative tip-speed ratio.  For location, 75% radius is often used, and for tip-speed ratio usually these fall within a fairly narrow range so it won't make a big difference as long we choose something reasonable.  In this example we will use a tsr of 6.  Propellers usually use advance ratio rather than tip-speed ratio, but these two quantities are related by: lambda = pi  J (so a tip-speed ratio of 6 would be an advance ratio of about 0.5)","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"alpha_rot = alpha_ext\ncl_rot = similar(cl_ext)\ncd_rot = similar(cd_ext)\n\nrR = 0.75  # r/R = 75%\ntsr = 6.0  # representative tip-speed ratio\n\nfor i = 1:length(cl_ext)\n    cl_rot[i], cd_rot[i] = rotation_correction(DuSeligEggers(), cl_ext[i], cd_ext[i], cr75, rR, tsr, alpha_ext[i])\nend","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"We will plot these just for visualization.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"\nfigure()\nplot(alpha_0, cl_0, label=\"original\")\nplot(alpha_ext, cl_ext, label=\"extrapolated\")\nplot(alpha_rot, cl_rot, label=\"rotation\")\nxlabel(L\"\\alpha\")\nylabel(L\"c_l\")\nlegend()\nsavefig(\"clcomp.svg\")\n\nfigure()\nplot(alpha_0, cd_0, label=\"original\")\nplot(alpha_ext, cd_ext, label=\"extrapolated\")\nplot(alpha_rot, cd_rot, label=\"rotation\")\nxlabel(L\"\\alpha\")\nylabel(L\"c_d\")\nlegend()\nsavefig(\"cdcomp.svg\")","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"(Image: ) (Image: )","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"The original data exhibits some numerical noise. We are using this data just for analysis in the tutorial, so that is fine. But for optimization we would likely want to use a smoothing spline on the original data so that our derivatives are well behaved (being careful not to apply to much smoothing to remove actual behavior).","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"We now save this data in a file so we can reuse it.  The info field just leaves an optional header in the file.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"af_final = AlphaAF(alpha_rot, cl_rot, cd_rot, \"NACA 4412 w/ rotation\", 5e4, 0.0)\nwrite_af(\"naca4412.dat\", af_final)","category":"page"},{"location":"howto/#Wind-Turbine-Operation","page":"Guided Examples","title":"Wind Turbine Operation","text":"","category":"section"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Nothing changes in the theory to permit operation as a propeller or as a turbine.  With sufficient change in twist, or inflow velocity, the lift will switch direction and the blade will change from requiring power to producing power.  However, to have an effective wind turbine one would want to flip the camber line so that the direction of a positive angle of attack corresponded to inflow from the \"bottom\" side of the airfoil (See Theory for more detail on this if interested).  Additionally, most of the positive conventions used for wind turbines are opposite those for propellers (directions for induction, twist, etc.).  For convenience, setting the turbine flag to true in defining the Rotor will use the positive directions shown below.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"(Image: inflowwt)","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"warning: Warning\nIf your application requires operation as both a turbine and a propeller (e.g., airborne wind) then you should pick one convention and stick with it.  Switching this flag does not force operation as a turbine, it just changes the convention for positive directions.  Those changes are merely a convenience except for camber, which is a design decision.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"As an example we will simulate the NREL 5 MW wind turbine.  Wind turbines generally have more complex inflow and airfoil schedules as compared to propellers, so this will also serve as a more advanced case compared to the introductory tutorial.  First, we load the packages.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"using CCBlade\nusing PyPlot","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Next, we define the Rotor.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"\nRhub = 1.5\nRtip = 63.0\nB = 3\nprecone = 2.5*pi/180\n\nrotor = Rotor(Rhub, Rtip, B, precone=precone, turbine=true)\n\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Next, we define the Section properties.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"\nr = [2.8667, 5.6000, 8.3333, 11.7500, 15.8500, 19.9500, 24.0500,\n    28.1500, 32.2500, 36.3500, 40.4500, 44.5500, 48.6500, 52.7500,\n    56.1667, 58.9000, 61.6333]\nchord = [3.542, 3.854, 4.167, 4.557, 4.652, 4.458, 4.249, 4.007, 3.748,\n    3.502, 3.256, 3.010, 2.764, 2.518, 2.313, 2.086, 1.419]\ntheta = pi/180*[13.308, 13.308, 13.308, 13.308, 11.480, 10.162, 9.011, 7.795,\n    6.544, 5.361, 4.188, 3.125, 2.319, 1.526, 0.863, 0.370, 0.106]\n\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"The airfoils are contained in files.  This wind turbine uses  8 different airfoils across the 17 different radial stations.  We first load the  airfoils, then assign them to the correct stations corresponding to the vector r defined previously.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"# Define airfoils.  In this case we have 8 different airfoils that we load into an array.\n# These airfoils are defined in files.\naftypes = Array{AlphaAF}(undef, 8)\naftypes[1] = AlphaAF(\"data/Cylinder1.dat\", radians=false)\naftypes[2] = AlphaAF(\"data/Cylinder2.dat\", radians=false)\naftypes[3] = AlphaAF(\"data/DU40_A17.dat\", radians=false)\naftypes[4] = AlphaAF(\"data/DU35_A17.dat\", radians=false)\naftypes[5] = AlphaAF(\"data/DU30_A17.dat\", radians=false)\naftypes[6] = AlphaAF(\"data/DU25_A17.dat\", radians=false)\naftypes[7] = AlphaAF(\"data/DU21_A17.dat\", radians=false)\naftypes[8] = AlphaAF(\"data/NACA64_A17.dat\", radians=false)\n\n# indices correspond to which airfoil is used at which station\naf_idx = [1, 1, 2, 3, 4, 4, 5, 6, 6, 7, 7, 8, 8, 8, 8, 8, 8]\n\n# create airfoil array\nairfoils = aftypes[af_idx]\n\n# define sections\nsections = Section.(r, chord, theta, airfoils)\n\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"We will use the windturbine_op function discussed in Input Structs.  The tip-speed ratio is 7.55.  We again use broadcasting because the velocities will vary at each radial station r.  There is no Reynolds or Mach number variation in our provided airfoil data and so we don't need to specify the viscosity or speed of sound.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"\n# operating point for the turbine\nyaw = 0.0*pi/180\ntilt = 5.0*pi/180\nhubHt = 90.0\nshearExp = 0.2\n\nVinf = 10.0\ntsr = 7.55\nrotorR = Rtip*cos(precone)\nOmega = Vinf*tsr/rotorR\npitch = 0.0\nazimuth = 0.0*pi/180\nrho = 1.225\n\nop = windturbine_op.(Vinf, Omega, pitch, r, precone, yaw, tilt, azimuth, hubHt, shearExp, rho)\n\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"We now solve","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"out = solve.(Ref(rotor), sections, op)\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"and plot the distributed loads:","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"# plot distributed loads\nfigure()\nplot(r/Rtip, out.Np/1e3)\nplot(r/Rtip, out.Tp/1e3)\nxlabel(\"r/Rtip\")\nylabel(\"distributed loads (kN/m)\")\nlegend([\"flapwise\", \"lead-lag\"])\nsavefig(\"loads-turbine.svg\")","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"(Image: )","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Next, we integrate the loads to get thrust and torque.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"T, Q = thrusttorque(rotor, sections, out)","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"This would give the thrust and torque assuming the inflow conditions were constant with azimuth (overly optimistic with this case at azimuth=0).  If one wanted to compute thrust and torque using azimuthal averaging you would compute multiple inflow conditions with different azimuth angles and then average the resulting forces.  This can be conveniently done with broadcasting.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"To do this we are broadcast across r and az_angles as a matrix of conditions. We will transpose az_angles into a row vector to make this happen.  If uncomfortable with broadcasting, all of these could all be done easily with for loops.  Notice that we transpose azangles so that the there is an input column vector for r and input row vector for azangles and the output is then a matrix corresponding to all these combinations.  The thrusttorque function is overloaded with a version that accepts a matrix of outputs where outputs[i, j] corresponds to r[i], azimuth[j] then performs an integration using averaging across the azimuthal conditions (or any other parameter).","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"azangles = pi/180*[0.0, 90.0, 180.0, 270.0]\nops = windturbine_op.(Vinf, Omega, pitch, r, precone, yaw, tilt, azangles', hubHt, shearExp, rho)\nouts = solve.(Ref(rotor), sections, ops)\n\nT, Q = thrusttorque(rotor, sections, outs)","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"As a final example, let's create a nondimensional power curve for this turbine (power coefficient vs tip-speed-ratio):","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"ntsr = 20  # number of tip-speed ratios\ntsrvec = range(2, 15, length=ntsr)\ncpvec = zeros(ntsr)  # initialize arrays\nctvec = zeros(ntsr)\n\nazangles = pi/180*[0.0, 90.0, 180.0, 270.0]\n\nfor i = 1:ntsr\n    local Omega = Vinf*tsrvec[i]/rotorR\n\n    local ops = windturbine_op.(Vinf, Omega, pitch, r, precone, yaw, tilt, azangles', hubHt, shearExp, rho)\n    local outs = solve.(Ref(rotor), sections, ops)\n    local T, Q = thrusttorque(rotor, sections, outs)\n\n    cpvec[i], ctvec[i], _ = nondim(T, Q, Vinf, Omega, rho, rotor, \"windturbine\")\nend","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"figure()\nplot(tsrvec, cpvec)\nplot(tsrvec, ctvec)\nxlabel(\"tip speed ratio\")\nlegend([L\"C_P\", L\"C_T\"])\nsavefig(\"cpct-turbine.svg\")","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"(Image: )","category":"page"},{"location":"howto/#Helicopter-Operation","page":"Guided Examples","title":"Helicopter Operation","text":"","category":"section"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Let's simulate the rotorcraft geometry from this NASA report.  The setup is standard to begin with.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"using CCBlade\nusing PyPlot","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"\nchord = 0.060\ntheta = 0.0\nRtip = 0.656\nRhub = 0.19*Rtip\nB = 3\n\nrotor = Rotor(Rhub, Rtip, B)\n\nr = range(Rhub, Rtip, length=30)\n\naf = AlphaAF(\"data/naca0012.txt\", radians=false)\nfunction af2(alpha, Re, M)\n    cl, cd = afeval(af, alpha, Re, M)\n    return cl, cd+0.014  # drag addition per report for Reynolds number adjustment\nend\nsections = Section.(r, chord, theta, af2)\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Notice that we put in zero for the freestream speed.  As discussed in the Theory document, the method has been extended to handle these special cases (alternatively you can use a small nonzero number, which utilizes the standard theory, but this is prone to occassional numerical noise in the output).  Also note that we use the nondimensionalization for helicopters.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"\nrho = 1.225\nOmega = 800*pi/30\nVinf = 0.0\n\nnP = 40\npitch = range(1e-4, 20*pi/180, length=nP)\n\nCT = zeros(nP)\nCQ = zeros(nP)\nFM = zeros(nP)\n\nfor i = 1:nP\n    op = simple_op.(Vinf, Omega, r, rho, pitch=pitch[i])\n    outputs = solve.(Ref(rotor), sections, op)\n    T, Q = thrusttorque(rotor, sections, outputs)\n    FM[i], CT[i], CQ[i] = nondim(T, Q, Vinf, Omega, rho, rotor, \"helicopter\")\nend\n\nsigma = B * chord / (pi * Rtip)\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Plotting the results against the provided experimental data.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"\nfigure()\nplot(CT/sigma, CQ/sigma, color=\"#348ABD\")\nxlim([0, 0.15])\nylim([0, 0.025])\nxlabel(L\"C_T/\\sigma\")\nylabel(L\"C_Q/\\sigma\", rotation=0)\n\ndata = [\n0.0006486486486486538 0.001826767151767151\n0.00021621621621621678 0.0019711018711018706\n0.0009729729729729721 0.0024036122661122636\n0.0021621621621621644 0.002283134095634097\n0.010594594594594595 0.0027378378378378337\n0.011351351351351346 0.0026174636174636154\n0.012540540540540546 0.0024008316008316023\n0.011675675675675679 0.003098154885654885\n0.012000000000000004 0.0034346153846153867\n0.017081081081081077 0.0035535862785862765\n0.01935135135135136 0.0036491943866943863\n0.017621621621621626 0.0029765332640332605\n0.017081081081081077 0.0028324324324324295\n0.019135135135135137 0.0027357848232848203\n0.05016216216216216 0.004891787941787941\n0.05059459459459458 0.005228222453222447\n0.054054054054054064 0.005684121621621619\n0.05502702702702702 0.006501195426195424\n0.05427027027027025 0.006597531185031182\n0.06940540540540538 0.007194854469854465\n0.07189189189189188 0.007410602910602908\n0.07243243243243241 0.007771049896049893\n0.07178378378378378 0.00810774428274428\n0.07675675675675675 0.008322895010395012\n0.0829189189189189 0.008657952182952181\n0.08572972972972973 0.009017853430353426\n0.08637837837837836 0.0090176975051975\n0.088 0.00923365384615384\n0.08637837837837836 0.009570582120582115\n0.0937297297297297 0.010602468814968808\n0.09448648648648647 0.010265748440748436\n0.09848648648648647 0.010841709979209978\n0.0963243243243243 0.011178768191268186\n0.09448648648648647 0.01264555613305613\n0.11589189189189186 0.014948102910602907\n0.11794594594594593 0.015139916839916836\n0.11816216216216216 0.015284095634095628\n0.11805405405405403 0.015596621621621619\n0.11502702702702702 0.015621387733887729\n0.11956756756756756 0.014586642411642408\n0.12054054054054059 0.014850831600831596\n0.1211891891891892 0.014850675675675672\n]\nplot(data[:, 1], data[:, 2], \"o\", color=\"#A60628\")\ntext(0.133, 0.014, \"BEM\", color=\"#348ABD\")\ntext(0.08, 0.017, \"experimental\", color=\"#A60628\")\ngca().yaxis.set_label_coords(-0.09,1.05)\nsavefig(\"rotorcraft1.svg\"); nothing # hide\n\nfigure()\nplot(CT/sigma, FM, color=\"#348ABD\")\nxlim([0, 0.15])\nylim([0, 0.7])\nxlabel(L\"C_T/\\sigma\")\nylabel(\"figure of merit\", rotation=0)\n\ndata = [\n0.0007194244604316561 0.0031982942430702765\n0.011305241521068862 0.09786780383795313\n0.017163412127440908 0.16439232409381654\n0.05056526207605345 0.45223880597014926\n0.07194244604316546 0.5462686567164178\n0.08581706063720454 0.5827292110874199\n0.09362795477903393 0.5641791044776119\n0.12127440904419323 0.5936034115138591\n0.11582733812949644 0.5533049040511726\n]\nplot(data[:, 1], data[:, 2], \"o\", color=\"#A60628\")\ntext(0.12, 0.67, \"BEM\", color=\"#348ABD\")\ntext(0.12, 0.5, \"experimental\", color=\"#A60628\")\ngca().yaxis.set_label_coords(0,1.05)\nsavefig(\"rotorcraft2.svg\");","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"(Image: ) (Image: )","category":"page"},{"location":"howto/#Computing-Derivatives","page":"Guided Examples","title":"Computing Derivatives","text":"","category":"section"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"The code is written in a generic enough way to allow for algorithmic differentiation through the entirety of the code.  This derivative workflow is not embeded in the package for a few reasons: 1) there are many different possible input/output combinations and trying to handle the most general cases would create a lot of extra data that may not be of interest, 2) there are many different AD packages one might want to use, 3) the code is often connected to others and one might want to AD a longer chain than just around CCBlade.  In any case, setting this is up is not too difficult.  Below is an example using ForwardDiff and ReverseDiff (note that ReverseDiff currently has an issue with concatenation so you must use version 1.2.0 for this example).","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"First, let's import some needed packages.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"import ForwardDiff\nimport ReverseDiff\nusing CCBlade","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Next, let's define the data for a simple propeller geometry.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"\nD = 1.6\nR = D/2.0\nRhub = 0.01\nRtip = D/2\nr = range(R/10, stop=9/10*R, length=11)\nchord = 0.1*ones(length(r))\nproppitch = 1.0  # pitch distance in meters.\ntheta = atan.(proppitch./(2*pi*r))\n\nfunction affunc(alpha, Re, M)\n\n    cl = 6.2*alpha\n    cd = 0.008 - 0.003*cl + 0.01*cl*cl\n\n    return cl, cd\nend\n\nn = length(r)\nairfoils = fill(affunc, n)\n\nB = 2  # number of blades\nturbine = false\npitch = 0.0\nprecone = 0.0\n\nrho = 1.225\nVinf = 30.0\nRPM = 2100\nOmega = RPM * pi/30\n\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Both ForwardDiff and ReverseDiff expect a function with a vector input and a vector output.  So we will need to create a wrapper function that takes in a vector x, which we parse into the variables of interest.  In this case we will compute thrust and torque.  This of course can be customized to any outputs of interest.  A few parameters: af, B, turbine are discrete, and cannot be differentiated, so we allow them to passthrough from the outer scope.  This part would be best wrapped in a function, rather than coming from global scope, but we're not worried about performance for this example.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"\n# parameters that passthrough: af, B, turbine\nfunction ccbladewrapper(x)\n\n    # unpack\n    nall = length(x)\n    nvec = nall - 7\n    n = nvec ÷ 3\n\n    r = x[1:n]\n    chord = x[n+1:2*n]\n    theta = x[2*n+1:3*n]\n    Rhub = x[3*n+1]\n    Rtip = x[3*n+2]\n    pitch = x[3*n+3]\n    precone = x[3*n+4]\n    Vinf = x[3*n+5]\n    Omega = x[3*n+6]\n    rho = x[3*n+7]\n\n    rotor = Rotor(Rhub, Rtip, B; turbine=turbine, precone=precone)\n    sections = Section.(r, chord, theta, airfoils)\n    ops = simple_op.(Vinf, Omega, r, rho; pitch=pitch)\n\n    outputs = solve.(Ref(rotor), sections, ops)\n\n    T, Q = thrusttorque(rotor, sections, outputs)\n\n    return [T; Q]\nend\n\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"We can now evaluate the Jacobian using forward mode AD.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"\nx = [r; chord; theta; Rhub; Rtip; pitch; precone; Vinf; Omega; rho]\nJ = ForwardDiff.jacobian(ccbladewrapper, x)","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"The Jacobian in this case is a 2 x 40 matrix because we have 2 outputs and 40 inputs.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"We could calculate the Jacobian with reverse mode AD instead.  Note that below is not the most efficient way to evaluate in reverse mode, especially if the derivatives will be computed repeatedly for more inputs (see ReverseDiff documentation).","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"J2 = ReverseDiff.jacobian(ccbladewrapper, x)","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"We can check that these matricies are nearly identical:","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"println(maximum(abs.(J - J2)))","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Generally, we should compare these derivatives against complex step, but the code is not currently complex safe, so we'll instead compare against central differencing.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"import FiniteDiff\nJ3 = FiniteDiff.finite_difference_jacobian(ccbladewrapper, x, Val{:central})\n\nimport Statistics: mean\n\nprintln(maximum(abs.(J - J3)))\nprintln(mean(abs.(J - J3)))","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"We can't expect as high of accuracy in comparing these Jacobians due to the limitations of finite differencing.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"The Jacobian is in terms of f (outputs) vs x (inputs).  For example, if we wanted to know dT/dchord we would use the same indexing we used when parsing x:","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"\ndTdchord = J[1, n+1:2*n]","category":"page"},{"location":"howto/#Computing-Derivatives-More-Efficiently","page":"Guided Examples","title":"Computing Derivatives More Efficiently","text":"","category":"section"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"The above method is simple, but not the most efficient.  First, most of the time we want to compute the derivatives many times (e.g., during an optimization) and so we should preallocate the Jacobian and populate it in place.  Second, the outputs of the wraqpper function are being reallocated many times so we should change that to be done in-place as well.  Third, if sparsity exists we should take advantage of it.  One case where sparsity occurs is when we are evaluting multiple inflow conditions (e.g., multiple flight states or multiple points on a power curve).  Each state/point is independent of the others and so there exists significant sparsity (see theory for more details).","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"We'll use the same geometry/setup as the previous example, but with a few changes: 1) we used a setup function so that variables are not in the global scope, 2) we allow for more than one inflow conditions (nV) and so instead of 2 outputs there are 2*nV outputs, 3) we modify the outputs in place (hence the use of an exclamation mark in the function name ccbladewrapper! per Julia convention).","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"using CCBlade\nimport ForwardDiff\n\n\nfunction setup(nV)\n\n    chord = 0.10\n    D = 1.6\n    RPM = 2100\n    pitchlength = 1.0  # pitch distance in meters.\n\n    turbine = false\n    Rhub = 0.01\n    Rtip = D/2\n    B = 2  # number of blades\n\n    R = D/2.0\n    n = 11\n    r = range(R/10, stop=9/10*R, length=n)\n    theta = atan.(pitchlength./(2*pi*r))\n    chord = chord*ones(n)\n\n    function affunc(alpha, Re, M)\n\n        cl = 6.2*alpha\n        cd = 0.008 - 0.003*cl + 0.01*cl*cl\n\n        return cl, cd\n    end\n\n    airfoils = fill(affunc, n)\n\n    pitch = 0.0\n    precone = 0.0\n\n    if nV == 1\n        Vinf = [30.0]\n    else\n        Vinf = range(29.0, 31.0, length=nV)\n    end\n\n    Omega = RPM * pi/30 * ones(nV)\n    rho = 1.225 * ones(nV)\n\n    x = [r; chord; theta; Rhub; Rtip; pitch; precone; Vinf; Omega; rho]\n    y = zeros(2*nV)\n\n    # parameters that passthrough: airfoils, B, turbine, n, nV\n    function ccbladewrapper!(y, x)\n\n        rp = x[1:n]\n        chordp = x[n+1:2*n]\n        thetap = x[2*n+1:3*n]\n        Rhubp = x[3*n+1]\n        Rtipp = x[3*n+2]\n        pitchp = x[3*n+3]\n        preconep = x[3*n+4]\n        idx = 3*n+4\n        Vinfp = x[idx+1:idx+nV]\n        Omegap = x[idx+nV+1:idx+2*nV]\n        rhop = x[idx+2*nV+1:idx+3*nV]\n\n        rotor = Rotor(Rhubp, Rtipp, B, turbine=turbine, precone=preconep)\n        sections = Section.(rp, chordp, thetap, airfoils)\n        ops = simple_op.(Vinfp', Omegap', rp, rhop')\n\n        outputs = solve.(Ref(rotor), sections, ops)\n\n        for i = 1:nV\n            T, Q = thrusttorque(rotor, sections, outputs[:, i])\n            y[i] = T\n            y[i+nV] = Q\n        end\n\n        return nothing\n    end\n\n    return x, y, ccbladewrapper!\nend\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Let's now use the same ForwardDiff setup we used previously, but now with an output function that modifies in place, and we will preallocate the Jacobian use the jacobian! function that modifies in place (we also preallocate the config see ForwardDiff documentation).  We will consider a case with 128 inflow conditions.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"nV = 128\nx, y, func = setup(nV)\nconfig = ForwardDiff.JacobianConfig(func, y, x)\nJ = zeros(length(y), length(x))  # preallocate Jacobian\nForwardDiff.jacobian!(J, func, y, x, config)  # results stored in J\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"We can compute the same Jacobian, but take advantage of the significant sparsity that exists.  We will make use of the SparseDiffTools package which builds off of ForwardDiff.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"import SparseArrays\nimport SparseDiffTools\n\nJsparse = SparseArrays.sparse(J)  # allocate a sparse matrix\ncolors = SparseDiffTools.matrix_colors(Jsparse)  # determine coloring vector\ncache = SparseDiffTools.ForwardColorJacCache(func, x, dx=y, colorvec=colors, sparsity=Jsparse)  # allocate cache\nSparseDiffTools.forwarddiff_color_jacobian!(Jsparse, func, x, cache)  # compute jacobian, results stored in Jsparse\nnothing # hide","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"We check that both provided the same output.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"println(maximum(abs.(J - Jsparse)))","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"Let's now compare computation time.","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"using BenchmarkTools\n\nt1 = @benchmark ForwardDiff.jacobian!($J, $func, $y, $x, $config)\nprintln(median(t1).time*1e-9)  # median time in seconds\nt2 = @benchmark SparseDiffTools.forwarddiff_color_jacobian!($Jsparse, $func, $x, $cache)\nprintln(median(t2).time*1e-9)  # median time in seconds","category":"page"},{"location":"howto/","page":"Guided Examples","title":"Guided Examples","text":"This represents about an order of magnitude speed up by leveraging sparsity.","category":"page"},{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Theory is detailed in the publication below and a preprint is available here.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Ning, A., “Using Blade Element Momentum Methods with Gradient-Based Design Optimization,” Apr. 2020, (in review).","category":"page"},{"location":"reference/#Reference","page":"API Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"This section describes the API in more detail.","category":"page"},{"location":"reference/#Input-Structs","page":"API Reference","title":"Input Structs","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"The rotor object is defined as follows.","category":"page"},{"location":"reference/#CCBlade.Rotor","page":"API Reference","title":"CCBlade.Rotor","text":"Rotor(Rhub, Rtip, B; precone=0.0, turbine=false,\n    mach=nothing, re=nothing, rotation=nothing, tip=PrandtlTipHub())\n\nParameters defining the rotor (apply to all sections).\n\nArguments\n\nRhub::Float64: hub radius (along blade length)\nRtip::Float64: tip radius (along blade length)\nB::Int64: number of blades\nprecone::Float64: precone angle\nturbine::Bool: true if using wind turbine conventions\nmach::MachCorrection: correction method for Mach number\nre::ReCorrection: correction method for Reynolds number\nrotation::RotationCorrection: correction method for blade rotation\ntip::TipCorrection: correction method for hub/tip loss\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"The precone angle is shown below (commonly used with wind turbines, less so with propellers).","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"(Image: precone)","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"If there is precone then the Rhub and Rtip dimensions correspond to the length along the blade (instead of the radius from the center of rotation).  That way when precone is changed, the blade just rotates instead of shearing as is more common.  The turbine parameter is used for wind turbines, as discussed in Wind Turbine Operation.  The remaining options are for airfoil (and tip loss) corrections and are discussed in Airfoil (and Tip) Corrections. ","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"The Section object is defined as follows:","category":"page"},{"location":"reference/#CCBlade.Section","page":"API Reference","title":"CCBlade.Section","text":"Section(r, chord, theta, af)\n\nDefine sectional properties for one station along rotor\n\nArguments\n\nr::Float64: radial location along blade\nchord::Float64: corresponding local chord length\ntheta::Float64: corresponding twist angle (radians)\naf::Function or AFType: if function form is: cl, cd = af(alpha, Re, Mach)\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Radius, like the hub and tip radii, follows along the blade.  Note that we usually only specify interior r points (e.g., strict inequalities for Rhub < r < Rtip).  However, CCBlade will allow you to specify points all the way to r = Rtip and/or r = Rhub, but because the loads are always zero at the hub/tip, the computation is bypassed for efficiency.  The thrust/torque integration always extrapolates to zero loads at the tip so there is no benefit to including the ends, however there is no harm either. ","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Positive twist is shown below.  ","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"(Image: inflow1)","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Airfoils are either a function as noted in the docstring, or a subtype of AFType, which in discussed in more detail in Airfoil Evaluation. ","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"The remaining input is the operating point:","category":"page"},{"location":"reference/#CCBlade.OperatingPoint","page":"API Reference","title":"CCBlade.OperatingPoint","text":"OperatingPoint(Vx, Vy, rho; pitch=0.0, mu=1.0, asound=1.0)\n\nOperation point for a rotor. The x direction is the axial direction, and y direction is the tangential direction in the rotor plane. See Documentation for more detail on coordinate systems. Vx and Vy vary radially at same locations as r in the rotor definition.\n\nArguments\n\nVx::Float64: velocity in x-direction along blade\nVy::Float64: velocity in y-direction along blade\npitch::Float64: pitch angle (radians)\nrho::Float64: fluid density\nmu::Float64: fluid dynamic viscosity (unused if Re not included in airfoil data)\nasound::Float64: fluid speed of sound (unused if Mach not included in airfoil data)\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"The inflow velocities V_x and V_y are seen in the figure above.  This allows to user to specify a completely general input, but usually these aren't specified directly.  Rather convenience functions are used to define these velocities across the blade (discussed below).  Dynamic viscosity is only need if the airfoil data contains multiple Reynolds number.  The speed of sound is only needed if the airfoil data contains multiple Mach numbers.  Pitch twists the entire blade in the same positive direction as twist.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"A simple propeller would have V_x = V_infty and V_y = Omega r.  That's essentially what the simple_op convenence function provides (with the addition of accounting for precone).  ","category":"page"},{"location":"reference/#CCBlade.simple_op","page":"API Reference","title":"CCBlade.simple_op","text":"simple_op(Vinf, Omega, r, rho; pitch=0.0, mu=1.0, asound=1.0, precone=0.0)\n\nUniform inflow through rotor.  Returns an OperatingPoint object.\n\nArguments\n\nVinf::Float: freestream speed (m/s)\nOmega::Float: rotation speed (rad/s)\nr::Float: radial location where inflow is computed (m)\nrho::Float: air density (kg/m^3)\npitch::Float: pitch angle (rad)\nmu::Float: air viscosity (Pa * s)\nasounnd::Float: air speed of sound (m/s)\nprecone::Float: precone angle (rad)\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"For wind turbines, a convenience function is provided windturbine_op that also includes yaw, tilt, azimuth, hub height, and a shear exponent.  ","category":"page"},{"location":"reference/#CCBlade.windturbine_op","page":"API Reference","title":"CCBlade.windturbine_op","text":"windturbine_op(Vhub, Omega, pitch, r, precone, yaw, tilt, azimuth, hubHt, shearExp, rho, mu=1.0, asound=1.0)\n\nCompute relative wind velocity components along blade accounting for inflow conditions and orientation of turbine.  See Documentation for angle definitions.\n\nArguments\n\nVhub::Float64: freestream speed at hub (m/s)\nOmega::Float64: rotation speed (rad/s)\npitch::Float64: pitch angle (rad)\nr::Float64: radial location where inflow is computed (m)\nprecone::Float64: precone angle (rad)\nyaw::Float64: yaw angle (rad)\ntilt::Float64: tilt angle (rad)\nazimuth::Float64: azimuth angle to evaluate at (rad)\nhubHt::Float64: hub height (m) - used for shear\nshearExp::Float64: power law shear exponent\nrho::Float64: air density (kg/m^3)\nmu::Float64: air viscosity (Pa * s)\nasound::Float64: air speed of sound (m/s)\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"(Image: )","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"To account for the velocity change across the hub face we compute the height of each blade location relative to the hub using coordinate transformations (where Phi is the precone angle):","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"  z_h = r cosPhi cospsi cosTheta + r sinPhisinTheta","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"then apply the shear exponent (alpha):","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"  V_shear = V_hub left(1 + fracz_hH_hub right)^alpha","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"where H_hub is the hub height.  Finally, we can compute the x- and y-components of velocity with additional coordinate transformations:","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"beginaligned\nV_x = V_shear ((cos gamma sin Theta cos psi + sin gamma sin psi)sin Phi + cos gamma cos Theta cos Phi)\nV_y = V_shear (cos gamma sin Thetasin psi - sin gamma cos psi) + Omega r cosPhi\nendaligned","category":"page"},{"location":"reference/#Output-Struct","page":"API Reference","title":"Output Struct","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"The full list of Outputs is as follows:","category":"page"},{"location":"reference/#CCBlade.Outputs","page":"API Reference","title":"CCBlade.Outputs","text":"Outputs(Np, Tp, a, ap, u, v, phi, alpha, W, cl, cd, cn, ct, F, G)\n\nOutputs from the BEM solver along the radius.\n\nArguments\n\nNp::Float64: normal force per unit length\nTp::Float64: tangential force per unit length\na::Float64: axial induction factor\nap::Float64: tangential induction factor\nu::Float64: axial induced velocity\nv::Float64: tangential induced velocity\nphi::Float64: inflow angle\nalpha::Float64: angle of attack\nW::Float64: inflow velocity\ncl::Float64: lift coefficient\ncd::Float64: drag coefficient\ncn::Float64: normal force coefficient\nct::Float64: tangential force coefficient\nF::Float64: hub/tip loss correction\nG::Float64: effective hub/tip loss correction for induced velocities: u = Vx * a * G, v = Vy * ap * G\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Most of these parameters are defined in the figure below.  The variables Np and Tp (where p is short for prime, as in a force per unit length) are in the cn and ct directions respectively.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"(Image: inflow2)","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"When using broadcasting to retrieve multiple outputs at once (as would be commonly done for multiple sections along a blade) the return type is a StructArray from the StructArrays.jl package. A StructArray acts like a normal Array when indexed with integers, but can also be indexed with the output names like Np and Tp. To show this, we'll create an example Output array of length 4 with random data:","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"using CCBlade\n\n# Create an array of `N` Outputs\nN = 4\nouts = Outputs.(rand(N), rand(N), rand(N), rand(N), rand(N), rand(N), rand(N), rand(N), rand(N), rand(N), rand(N), rand(N), rand(N), rand(N), rand(N))","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Now we can retrieve all of the inputs for e.g. the third entry by indexing with an integer:","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"outs[3]","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"But we can also get all of the e.g. Np outputs using outs.Np:","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"outs.Np","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"This was shown in the introductory tutorial. The same is true for the Section and OperatingPoint structs.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"One subtle notes regarding the way the tip-loss factor works.  The BEM methodology applies hub/tip losses to the loads rather than to the velocities.  This is the most common way to implement a BEM, but it means that the raw velocities may be misleading as they do not contain any hub/tip loss corrections.  To fix this we compute the effective hub/tip losses that would produce the same thrust/torque.  In other words: C_T = 4 a (1 + a) F = 4 a G (1 + a G) We solve this for G, and multiply it against the returned wake velocities u and v (but not the induction factors).  Doing so allows us to return consistent values for the wake velocities, which may be of interest when computing interactions between rotor wakes and other objects.","category":"page"},{"location":"reference/#Solve","page":"API Reference","title":"Solve","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Solve is the main function that takes in the three input structs (Rotor, Section, OperatingPoint) and returns the output struct (Outputs).  Often broadcasting is used to call this function at multiple sections, or multiple sections and multiple operating points.","category":"page"},{"location":"reference/#CCBlade.solve","page":"API Reference","title":"CCBlade.solve","text":"solve(rotor, section, op; npts=10, forcebackwardsearch=false, epsilon_everywhere=false)\n\nSolve the BEM equations for given rotor geometry and operating point.\n\nArguments\n\nrotor::Rotor: rotor properties\nsection::Section: section properties\nop::OperatingPoint: operating point\nnpts::Int = 10: number of discretization points for phi state variable, used to find bracket for residual solve\nforcebackwardsearch::Bool = false: if true, force bracket search from high phi values to low, otherwise let solve decide\nepsilon_everywhere::Bool = false: if true, don't evaluate at intersections of phi quadrants (pi/2, -pi/2, etc.)\nimplicitad_option=true: if true, uses ImplicitAD to compute derivatives around solver when using AD; if false, bypasses ImplicitAD\n\nReturns\n\noutputs::Outputs: BEM output data including loads, induction factors, etc.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Integrated-Loads","page":"API Reference","title":"Integrated Loads","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"After solving, the distributed loads can be integrated to provide thrust and torque using the function thrusttorque.","category":"page"},{"location":"reference/#CCBlade.thrusttorque-Union{Tuple{TO}, Tuple{Any, Any, Vector{TO}}} where TO","page":"API Reference","title":"CCBlade.thrusttorque","text":"thrusttorque(rotor, sections, outputs::AbstractVector{TO}) where TO\n\nintegrate the thrust/torque across the blade, including 0 loads at hub/tip, using a trapezoidal rule.\n\nArguments\n\nrotor::Rotor: rotor object\nsections::Vector{Section}: rotor object\noutputs::Vector{Outputs}: output data along blade\n\nReturns\n\nT::Float64: thrust (along x-dir see Documentation).\nQ::Float64: torque (along x-dir see Documentation).\n\n\n\n\n\n","category":"method"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"The method extends to loads to the hub/tip (where the loads go to zero) to capture the small contribution to thrust and torque from the ends of the r vector to Rhub and Rtip.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"There is also an overloaded version where a matrix of outputs is input for azimuthal averaging (mainly used for wind turbines).","category":"page"},{"location":"reference/#CCBlade.thrusttorque-Union{Tuple{TO}, Tuple{Any, Any, Matrix{TO}}} where TO","page":"API Reference","title":"CCBlade.thrusttorque","text":"thrusttorque(rotor, sections, outputs::AbstractMatrix{TO}) where TO\n\nIntegrate the thrust/torque across the blade given an array of output data. Generally used for azimuthal averaging of thrust/torque. outputs[i, j] corresponds to sections[i], azimuth[j].  Integrates across azimuth\n\n\n\n\n\n","category":"method"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Often we want to nondimensionalize the outputs.  The nondimensionalization uses different conventions depending on the name assigned in rotortype.  ","category":"page"},{"location":"reference/#CCBlade.nondim","page":"API Reference","title":"CCBlade.nondim","text":"nondim(T, Q, Vhub, Omega, rho, rotor, rotortype)\n\nNondimensionalize the outputs.\n\nArguments\n\nT::Float64: thrust (N)\nQ::Float64: torque (N-m)\nVhub::Float64: hub speed used in turbine normalization (m/s)\nOmega::Float64: rotation speed used in propeller normalization (rad/s)\nrho::Float64: air density (kg/m^3)\nrotor::Rotor: rotor object\nrotortype::String: normalization type\n\nReturns\n\nif rotortype == \"windturbine\"\n\nCP::Float64: power coefficient\nCT::Float64: thrust coefficient\nCQ::Float64: torque coefficient\n\nif rotortype == \"propeller\"\n\neff::Float64: efficiency\nCT::Float64: thrust coefficient\nCQ::Float64: torque coefficient\n\nif rotortype == \"helicopter\"\n\nFM::Float64: figure of merit\nCT::Float64: thrust coefficient\nCQ or CP::Float64: torque/power coefficient (they are identical)\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"For rotortype = \"windturbine\" the following outputs are returned:","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"beginaligned\nC_P = fracPq A V_hub\nC_T = fracTq A\nC_Q = fracQq R_disk A\nendaligned","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"where","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"beginaligned\nR_disk = R_tip cos(textprecone)\nA = pi R_disk^2\nq = frac12rho V_hub^2\nendaligned","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"For type = \"propeller\" the return outputs are:","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"beginaligned\neta = fracT V_hubP\nC_T = fracTrho n^2 D^4\nC_Q = fracQrho n^2 D^5\nendaligned","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"where","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"beginaligned\nD = 2 R_disk\nn = fracOmega2pi\nendaligned","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"For type = \"helicopter\" the return outputs are:","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"beginaligned\nFM = fracC_T^32sqrt2 C_P\nC_T = fracTrho A (Omega R_disk)^2\nC_P = fracPrho A (Omega R_disk)^3\nendaligned","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"note that with this definition C_Q = C_P.","category":"page"},{"location":"reference/#Airfoil-Evaluation","page":"API Reference","title":"Airfoil Evaluation","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"The main airfoil evaluation function is afeval.","category":"page"},{"location":"reference/#CCBlade.afeval-Tuple{AFType, Any, Any, Any}","page":"API Reference","title":"CCBlade.afeval","text":"afeval(af::AFType, alpha, Re, Mach)\n\nEvaluate airfoil aerodynamic performance\n\nArguments\n\naf::AFType or Function: dispatch on AFType or if function call: cl, cd = af(alpha, Re, Mach)\nalpha::Float64: angle of attack in radians\nRe::Float64: Reynolds number\nMach::Float64: Mach number\n\nReturns\n\ncl::Float64: lift coefficient\ncd::Float64: drag coefficient\n\n\n\n\n\n","category":"method"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"It dispatches based on subtypes of AFType or any Function of the form noted in the docstring.  Several subtypes of AFType are implemented.  The first is SimpleAF.","category":"page"},{"location":"reference/#CCBlade.SimpleAF","page":"API Reference","title":"CCBlade.SimpleAF","text":"SimpleAF(m, alpha0, clmax, clmin, cd0, cd2)\n\nA simple parameterized lift and drag curve.  \n\ncl = m (alpha - alpha0) (capped by clmax/clmin)\ncd = cd0 + cd2 * cl^2\n\nArguments\n\nm::Float64: lift curve slope\nalpha0::Float64: zero-lift angle of attack\nclmax::Float64: maximum lift coefficient\nclmin::Float64: minimum lift coefficient\ncd0::Float64: zero lift drag\ncd2::Float64: quadratic drag term\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"This form is mostly useful for testing, or really simple analyse.  Next, and perhaps the most common type is AlphaAF. This type takes in arrays of data and creates an Akima spline with variation just in angle of attack.  It can also be initialized from a file (format discussed below).  ","category":"page"},{"location":"reference/#CCBlade.AlphaAF","page":"API Reference","title":"CCBlade.AlphaAF","text":"AlphaAF(alpha, cl, cd, info, Re, Mach)\nAlphaAF(alpha, cl, cd, info, Re=0.0, Mach=0.0)\nAlphaAF(alpha, cl, cd, info=\"CCBlade generated airfoil\", Re=0.0, Mach=0.0)\nAlphaAF(filename::String; radians=true)\n\nAirfoil data that varies with angle of attack.  Data is fit with an Akima spline.\n\nArguments\n\nalpha::Vector{Float64}: angles of attack\ncl::Vector{Float64}: corresponding lift coefficients\ncd::Vector{Float64}: corresponding drag coefficients\ninfo::String: a description of this airfoil data (just informational)\nRe::Float64: Reynolds number data was taken at (just informational)\nMach::Float64: Mach number data was taken at (just informational)\n\nor\n\na file\n\nArguments\n\nfilename::String: name/path of file to read in\nradians::Bool: true if angle of attack in file is given in radians\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Similar forms exist for variation with angle of attack and Reynolds number:","category":"page"},{"location":"reference/#CCBlade.AlphaReAF","page":"API Reference","title":"CCBlade.AlphaReAF","text":"AlphaReAF(alpha, Re, cl, cd, info, Mach)\nAlphaReAF(alpha, Re, cl, cd, info)\nAlphaReAF(alpha, Re, cl, cd)\nread_AlphaReAF(filenames::Vector{String}; radians=true)\n\nAirfoil data that varies with angle of attack and Reynolds number.   Data is fit with a recursive Akima spline.\n\nArguments\n\nalpha::Vector{Float64}: angles of attack\nRe::Vector{Float64}: Reynolds numbers\ncl::Matrix{Float64}: lift coefficients where cl[i, j] corresponds to alpha[i], Re[j]\ncd::Matrix{Float64}: drag coefficients where cd[i, j] corresponds to alpha[i], Re[j]\ninfo::String: a description of this airfoil data (just informational)\nMach::Float64: Mach number data was taken at (just informational)\n\nor\n\nfilenames with one file per Reynolds number.\n\nArguments\n\nfilenames::Vector{String}: name/path of files to read in, each at a different Reynolds number in ascending order\nradians::Bool: true if angle of attack in file is given in radians\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"angle of attack and Mach number:","category":"page"},{"location":"reference/#CCBlade.AlphaMachAF","page":"API Reference","title":"CCBlade.AlphaMachAF","text":"AlphaMachAF(alpha, Mach, cl, cd, info, Re)\nAlphaMachAF(alpha, Mach, cl, cd, info)\nAlphaMachAF(alpha, Mach, cl, cd)\nAlphaMachAF(filenames::Vector{String}; radians=true)\n\nAirfoil data that varies with angle of attack and Mach number.   Data is fit with a recursive Akima spline.\n\nArguments\n\nalpha::Vector{Float64}: angles of attack\nMach::Vector{Float64}: Mach numbers\ncl::Matrix{Float64}: lift coefficients where cl[i, j] corresponds to alpha[i], Mach[j]\ncd::Matrix{Float64}: drag coefficients where cd[i, j] corresponds to alpha[i], Mach[j]\ninfo::String: a description of this airfoil data (just informational)\nRe::Float64: Reynolds number data was taken at (just informational)\n\nor\n\nfilenames with one file per Mach number.\n\nArguments\n\nfilenames::Vector{String}: name/path of files to read in, each at a different Mach number in ascending order\nradians::Bool: true if angle of attack in file is given in radians\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"and all three (angle of attack, Reynolds number, Mach number):","category":"page"},{"location":"reference/#CCBlade.AlphaReMachAF","page":"API Reference","title":"CCBlade.AlphaReMachAF","text":"AlphaReMachAF(alpha, Re, Mach, cl, cd, info)\nAlphaReMachAF(alpha, Re, Mach, cl, cd)\nAlphaReMachAF(filenames::Matrix{String}; radians=true)\n\nAirfoil data that varies with angle of attack, Reynolds number, and Mach number.   Data is fit with a recursive Akima spline.\n\nArguments\n\nalpha::Vector{Float64}: angles of attack\nRe::Vector{Float64}: Reynolds numbers\nMach::Vector{Float64}: Mach numbers\ncl::Array{Float64}: lift coefficients where cl[i, j, k] corresponds to alpha[i], Re[j], Mach[k]\ncd::Array{Float64}: drag coefficients where cd[i, j, k] corresponds to alpha[i], Re[j], Mach[k]\ninfo::String: a description of this airfoil data (just informational)\n\nor files with one per Re/Mach combination\n\nArguments\n\nfilenames::Matrix{String}: name/path of files to read in.  filenames[i, j] corresponds to Re[i] Mach[j] with Reynolds number and Mach number in ascending order.\nradians::Bool: true if angle of attack in file is given in radians\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"More generally the user can provide any function of the form cl, cd = af(alpha, Re Mach) or can create their own subtypes of AFType to be used by CCBlade.","category":"page"},{"location":"reference/#Airfoil-Files","page":"API Reference","title":"Airfoil Files","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Because many of these formats require storing long vectors/matrices of data, it is convenient to store them in files.  There are multiple convenience methods for reading and writing files based on the implemented AFType subtypes.  The file format for all airfoil files is as follows:","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"______\ninformational line (arbitrary string just for information)\nRe (float, Reynolds number data was taken at)\nMach (float, Mach number data was taken at)\nalpha1  cl1  cd1  (columns of data separated by space for angle of attack, lift coefficient, and drag coefficient)\nalpha2  cl2  cd2\nalpha3  cl3  cd3\n...\n–––","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"In addition to reading these in directly, you can write data to a file, which is dispatched based on the AFType.","category":"page"},{"location":"reference/#CCBlade.write_af","page":"API Reference","title":"CCBlade.write_af","text":"write_af(filename(s), af::AFType; radians=true)\n\nWrite airfoil data to file\n\nArguments\n\nfilename(s)::String or Vector{String} or Matrix{String}: name/path of file to write to\naf::AFType: writing is dispatched based on type (AlphaAF, AlphaReAF, etc.)\nradians::Bool: true if you want angle of attack to be written in radians\n\n\n\n\n\n","category":"function"},{"location":"reference/#Airfoil-(and-Tip)-Corrections","page":"API Reference","title":"Airfoil (and Tip) Corrections","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Various airfoil correction methods exist for Mach number, Reynolds number, and rotation effects.  Additionally, custom tip loss corrections can be specified.  For Mach number and Reynolds number the form is similar.  For Mach number, there is the mach_correction function that dispatches based on subtypes of MachCorrection.","category":"page"},{"location":"reference/#CCBlade.mach_correction-Tuple{MachCorrection, Any, Any, Any}","page":"API Reference","title":"CCBlade.mach_correction","text":"mach_correction(::MachCorrection, cl, cd, Mach)\n\nMach number correction for lift/drag coefficient\n\nArguments\n\nmc::MachCorrection: used for dispatch\ncl::Float64: lift coefficient before correction\ncd::Float64: drag coefficient before correction\nMach::Float64: Mach number\n\nReturns\n\ncl::Float64: lift coefficient after correction\ncd::Float64: drag coefficient after correction\n\n\n\n\n\n","category":"method"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"For example, a Prandtl-Glauert correction is available:","category":"page"},{"location":"reference/#CCBlade.mach_correction-Tuple{PrandtlGlauert, Any, Any, Any}","page":"API Reference","title":"CCBlade.mach_correction","text":"mach_correction(::PrandtlGlauert, cl, cd, Mach)\n\nPrandtl/Glauert Mach number correction for lift coefficient\n\n\n\n\n\n","category":"method"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Similarly, Reynolds number corrections use the re_correction function with dispatching based on subtypes of ReCorrection","category":"page"},{"location":"reference/#CCBlade.re_correction-Tuple{ReCorrection, Any, Any, Any}","page":"API Reference","title":"CCBlade.re_correction","text":"re_correction(re::ReCorrection, cl, cd, Re)\n\nReynolds number correction for lift/drag coefficient\n\nArguments\n\nre::ReCorrection: used for dispatch\ncl::Float64: lift coefficient before correction\ncd::Float64: drag coefficient before correction\nRe::Float64: Reynolds number\n\nReturns\n\ncl::Float64: lift coefficient after correction\ncd::Float64: drag coefficient after correction\n\n\n\n\n\n","category":"method"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"A skin friction model based on flat plate increases in drag coefficient with Reynolds number is implemented:","category":"page"},{"location":"reference/#CCBlade.SkinFriction","page":"API Reference","title":"CCBlade.SkinFriction","text":"SkinFriction(Re0, p)\n\nSkin friction model for a flat plate. cd *= (Re0 / Re)^p\n\nArguments\n\nRe0::Float64: reference Reynolds number (i.e., no corrections at this number)\np::Float64: exponent in flat plate model.  0.5 for laminar (Blasius solution), ~0.2 for fully turbulent (Schlichting empirical fit)\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"For convenience, there is also LaminarSkinFriction(Re0) and TurbulentSkinFriction(Re0) to set the exponent p for typical values for fully laminar and fully turbulent flow respectively.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Rotational corrections for 3D stall delay use the rotation_correction function that dispatches on subtypes of RotationCorrection.","category":"page"},{"location":"reference/#CCBlade.rotation_correction","page":"API Reference","title":"CCBlade.rotation_correction","text":"rotation_correction(rc::RotationCorrection, cl, cd, cr, rR, tsr, alpha, phi=alpha, alpha_max_corr=30*pi/180)\n\nRotation correction (3D stall delay).\n\nArguments\n\nrc::RotationCorrection: used for dispatch\ncl::Float64: lift coefficient before correction\ncd::Float64: drag coefficient before correction\ncr::Float64: local chord / local radius\nrR::Float64: local radius / tip radius\ntsr::Float64: local tip speed ratio (Omega r / Vinf)\nalpha::Float64: local angle of attack\nphi::Float64: local inflow angles (defaults to angle of attack is precomputing since it is only known for on-the-fly computations)\nalpha_max_corr::Float64: angle of attack for maximum correction (tapers off to zero by 90 degrees)\n\nReturns\n\ncl::Float64: lift coefficient after correction\ncd::Float64: drag coefficient after correction\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"A supplied correction method uses the Du-Selig method for lift and the Eggers method for drag.","category":"page"},{"location":"reference/#CCBlade.DuSeligEggers","page":"API Reference","title":"CCBlade.DuSeligEggers","text":"DuSeligEggers(a, b, d, m, alpha0)\nDuSeligEggers(a=1.0, b=1.0, d=1.0, m=2*pi, alpha0=0.0)  # uses defaults\n\nDuSelig correction for lift an Eggers correction for drag.\n\nArguments\n\na, b, d::Float64: parameters in Du-Selig paper.  Normally just 1.0 for each.\nm::Float64: lift curve slope.  Defaults to 2 pi for zero argument version.\nalpha0::Float64: zero-lift angle of attack.  Defaults to 0 for zero argument version.\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Finally, tip loss corrections are provided by the tip_correction function dispatching based on TipCorrection.","category":"page"},{"location":"reference/#CCBlade.tip_correction","page":"API Reference","title":"CCBlade.tip_correction","text":"tip_correction(::TipCorrection, r, Rhub, Rtip, phi, B)\n\nTip corrections for 3D flow.\n\nArguments\n\ntc::TipCorrection: used for dispatch\nr::Float64: local radius\nRhub::Float64: hub radius\nRtip::Float64: tip radius\nphi::Float64: inflow angle\nB::Integer: number of blades\n\nReturns\n\nF::Float64: tip loss factor to multiple against loads.\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Two provided corrections are Prandtl tip loss, and Prandtl tip and hub loss.","category":"page"},{"location":"reference/#CCBlade.PrandtlTip","page":"API Reference","title":"CCBlade.PrandtlTip","text":"PrandtlTip()\n\nStandard Prandtl tip loss correction.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CCBlade.PrandtlTipHub","page":"API Reference","title":"CCBlade.PrandtlTipHub","text":"PrandtlTipHub()\n\nStandard Prandtl tip loss correction plus hub loss correction of same form.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Airfoil-Extrapolation","page":"API Reference","title":"Airfoil Extrapolation","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"While not used in CCBlade directly, for convenience a preprocessing method is provided to extrapolate airfoil coefficient data from -pi to pi.","category":"page"},{"location":"reference/#CCBlade.viterna","page":"API Reference","title":"CCBlade.viterna","text":"viterna(alpha, cl, cd, cr75, nalpha=50)\n\nViterna extrapolation.  Follows Viterna paper and somewhat follows NREL version of AirfoilPrep, but with some modifications for better robustness and smoothness.\n\nArguments\n\nalpha::Vector{Float64}: angles of attack\ncl::Vector{Float64}: correspnding lift coefficients\ncd::Vector{Float64}: correspnding drag coefficients\ncr75::Float64: chord/Rtip at 75% Rtip\nnalpha::Int64: number of discrete points (angles of attack) to include in extrapolation\n\nReturns\n\nalpha::Vector{Float64}: angle of attack from -pi to pi\ncl::Vector{Float64}: correspnding extrapolated lift coefficients\ncd::Vector{Float64}: correspnding extrapolated drag coefficients\n\n\n\n\n\n","category":"function"},{"location":"#CCBlade-Documentation","page":"Intro","title":"CCBlade Documentation","text":"","category":"section"},{"location":"","page":"Intro","title":"Intro","text":"Summary: A blade element momentum method for propellers and turbines.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Author: Andrew Ning","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Features:","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Methodology is provably convergent (see http://dx.doi.org/10.1002/we.1636 although multiple improvements have been made since then)\nPrandtl hub/tip losses (or user-defined losses)\nGlauert/Buhl empirical region for high thrust turbines\nConvenience functions for inflow with shear, precone, yaw, tilt, and azimuth\nCan do airfoil corrections beforehand or on the fly (Mach, Reynolds, rotation)\nAllows for flow reversals (negative inflow/rotation velocities)\nAllows for a hover condition (only rotation, no inflow) and rotor locked (no rotation, only inflow)\nCompatible with AD tools like ForwardDiff","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Installation:","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"pkg> add CCBlade","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Documentation:","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Start with the quick start tutorial to learn basic usage.\nMore advanced or specific queries are addressed in the guided examples.\nFull details of the API are listed in reference.\nFull details of the theory are linked from the theory page.","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Run Unit Tests:","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"pkg> activate .\npkg> test","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Citing:","category":"page"},{"location":"","page":"Intro","title":"Intro","text":"Ning, A., “Using Blade Element Momentum Methods with Gradient-Based Design Optimization,” Structural and Multidisciplinary Optimization, Vol. 64, No. 2, pp. 994–1014, May 2021. doi:10.1007/s00158-021-02883-6","category":"page"},{"location":"tutorial/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"This starter tutorial walks through the mechanics of running a analysis.  This is designing as a starting point and does not explain every option or consideration.  More specific and advanced usage are described in the how to guide.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"We will simulate the APC thin electric 10 x 5 propeller.  The geometry, and wind tunnel data for this propeller is available from UIUC. Let's load CCBlade and a plotting package (I use PyPlot in these examples).","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"using CCBlade\nusing PyPlot","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"There are two parts of the geometry we need to define: the first are quantities for the whole rotor, and the second part defines properties that vary along the blade radius.  For the rotor, we only need to define the hub radius, tip radius, and the number of blades.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"This is a two-bladed propeller, and the 10 in the name (10 x 5) means it has a diameter of 10 inches (and so the tip radius is half of that).  I prefer to do all calculations in metric units so I'll convert it.  From the geometry table for this propeller we see that the hub radius is less than 015 R_tip.  It isn't defined exactly, and is less critical, we'll assume 010 R_tip for this example.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"Rtip = 10/2.0 * 0.0254  # inches to meters\nRhub = 0.10*Rtip\nB = 2  # number of blades\n\nrotor = Rotor(Rhub, Rtip, B)\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"Next, we define the geometry along the different radial stations.   The more radial stations we add, the more points we will compute loads at.  There is a tradeoff here in computational time and accuracy in representing (and integrating) loads. The geometry table defines the normalized radial stations, normalized chord, and the twist angle in degrees.  CCBlade assumes all angles are given in radians so we will need to convert that, we will also unnormalize the radius and chord (alternatively we could do everything in consistent nondimensional units).","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"propgeom = [\n0.15   0.130   32.76\n0.20   0.149   37.19\n0.25   0.173   33.54\n0.30   0.189   29.25\n0.35   0.197   25.64\n0.40   0.201   22.54\n0.45   0.200   20.27\n0.50   0.194   18.46\n0.55   0.186   17.05\n0.60   0.174   15.97\n0.65   0.160   14.87\n0.70   0.145   14.09\n0.75   0.128   13.39\n0.80   0.112   12.84\n0.85   0.096   12.25\n0.90   0.081   11.37\n0.95   0.061   10.19\n1.00   0.041   8.99\n]\n\nr = propgeom[:, 1] * Rtip\nchord = propgeom[:, 2] * Rtip\ntheta = propgeom[:, 3] * pi/180\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"The remaining piece in defining the geometry is the airfoils.  We don't actually define the airfoil geometry, but rather the aerodynamic performance data of the airfoils at each station (lift and drag coefficients).  This propeller uses the NACA 4412 airfoil, for which experimental data is readily available, or for which computational data can be easily provided. The data for this airfoil is contained in a file \"naca4412.dat\" (in the data directory of the repository).  The file format is discussed in Airfoil Files.  There are some important details to be aware of when providing airfoil data–-the way this file was constructed is covered in Airfoil Data.  For now, we just assume provided airfoil data.  The file extension is not important, all that matters is that the format has columns of data for: angle of attack | lift coefficient | drag coefficient (after an informational header row, a row for Reynolds number, and a row for Mach number).  We can either put in the full or relative path to the file, for example if you were in the home directory of this repository:","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"af = AlphaAF(\"data/naca4412.dat\")\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"or we can change directory (note the semicolon to enter shell mode from the REPL):","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"; cd data\naf = AlphaAF(\"naca4412.dat\")","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"We can now define the sections using this airfoil data.  Since Section is defined for one section, and we'd like to define them all simultaneously, we use broadcasting (see the dot after Section).  The airfoil is the same for all stations along the rotor so we wrap it in a Ref() call so that it can be broadcast across.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"sections = Section.(r, chord, theta, Ref(af))\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"Next, we define the operating point(s).  You can define your own arbitrary inflow struct, but for this example we will assume constant inflow across the rotor.  We again use broadcasting because the velocities will vary at each radial station r.  For this simple method we just need to know the freestream speed, rotation speed, and the air density.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"\nVinf = 5.0\nOmega = 5400*pi/30  # convert to rad/s\nrho = 1.225\n\nop = simple_op.(Vinf, Omega, r, rho)\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"We have now defined the requisite inputs and can start using the BEM methodology.  The solve function is the core of the BEM. Note that we use broadcasting to solve all sections in one call.  However, since rotor is not an Array, and is the same for all sections, we wrap it in Ref so that it can broadcast as a \"scalar\".","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"\nout = solve.(Ref(rotor), sections, op)\n\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"There are many outputs, and although the return variable is actually an array of structs, convenience methods are provided to access the fields as if it was a struct of arrays.  For example, we can access the angles of attack at each radial station as:","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"out.alpha*180/pi  # angle of attack in degrees","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"The full list of outputs and their positive directions are shown in Output Struct.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"Let's now plot the distributed loads.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"figure()\nplot(r/Rtip, out.Np)\nplot(r/Rtip, out.Tp)\nxlabel(\"r/Rtip\")\nylabel(\"distributed loads (N/m)\")\nlegend([\"flapwise\", \"lead-lag\"])","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"<!– # savefig(\"loads-prop.svg\") –>","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"We will also look at the induced velocities.  For propellers these velocities are useful to assess, for example, prop-on-wing interactions.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"figure()\nplot(r/Rtip, out.u/Vinf)\nplot(r/Rtip, out.v/Vinf)\nxlabel(\"r/Rtip\")\nylabel(\"(normalized) induced velocity at rotor disk\")\nlegend([\"axial velocity\", \"swirl velocity\"])","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"(Image: )","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"As before, we'd like to evaluate integrated quantities at multiple conditions in a for loop (advance ratios as is convention for propellers).  The normalization conventions for a propeller are:","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"beginaligned\nC_T = fracTrho n^2 D^4\nC_Q = fracQrho n^2 D^5\nC_P = fracPrho n^3 D^5 = fracC_Q2 pi\neta = fracC_T JC_P\nendaligned","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"where","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"beginaligned\nn = fracOmega2pi text rev per sec\nD = 2 R_tip cos(textprecone)\nJ = fracVn D\nendaligned","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"note: Note\nEfficiency is set to zero if the thrust is negative (producing drag).","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"The code below performs this analysis then plots thrust coefficient, power coefficient, and efficiency as a function of advance ratio as compared to the experimental data.","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"nJ = 20  # number of advance ratios\n\nJ = range(0.1, 0.6, length=nJ)  # advance ratio\n\nOmega = 5400.0*pi/30\nn = Omega/(2*pi)\nD = 2*Rtip\n\neff = zeros(nJ)\nCT = zeros(nJ)\nCQ = zeros(nJ)\n\nfor i = 1:nJ\n    local Vinf = J[i] * D * n\n\n    local op = simple_op.(Vinf, Omega, r, rho)\n    outputs = solve.(Ref(rotor), sections, op)\n    T, Q = thrusttorque(rotor, sections, outputs)\n    eff[i], CT[i], CQ[i] = nondim(T, Q, Vinf, Omega, rho, rotor, \"propeller\")\n\nend\n\nexp = [\n0.113   0.0912   0.0381   0.271\n0.145   0.0890   0.0386   0.335\n0.174   0.0864   0.0389   0.387\n0.200   0.0834   0.0389   0.429\n0.233   0.0786   0.0387   0.474\n0.260   0.0734   0.0378   0.505\n0.291   0.0662   0.0360   0.536\n0.316   0.0612   0.0347   0.557\n0.346   0.0543   0.0323   0.580\n0.375   0.0489   0.0305   0.603\n0.401   0.0451   0.0291   0.620\n0.432   0.0401   0.0272   0.635\n0.466   0.0345   0.0250   0.644\n0.493   0.0297   0.0229   0.640\n0.519   0.0254   0.0210   0.630\n0.548   0.0204   0.0188   0.595\n0.581   0.0145   0.0162   0.520\n]\nJexp = exp[:, 1]\nCTexp = exp[:, 2]\nCPexp = exp[:, 3]\netaexp = exp[:, 4]","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"figure()\nplot(J, CT)\nplot(J, CQ*2*pi)\nplot(Jexp, CTexp, \"ko\")\nplot(Jexp, CPexp, \"ko\")\nxlabel(L\"J\")\nlegend([L\"C_T\", L\"C_P\", \"experimental\"])\n\nfigure()\nplot(J, eff)\nplot(Jexp, etaexp, \"ko\")\nxlabel(L\"J\")\nylabel(L\"\\eta\")\nlegend([\"CCBlade\", \"experimental\"])","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"(Image: ) (Image: )","category":"page"},{"location":"tutorial/","page":"Quick Start","title":"Quick Start","text":"There is reasonable agreement, certainly within experimental/computational error.  Accurate airfoil data is always the most crucial input for these methods.  Working with various corrections and setup of the airfoil data is discussed more in Airfoil Data.","category":"page"}]
}
